<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HTGS: htgs::TaskGraphCommunicator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhtgs_1_1_task_graph_communicator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhtgs_1_1_task_graph_communicator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">htgs::TaskGraphCommunicator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the task graph communicator where a task's address and name are mapped to their input connectors.  
 <a href="classhtgs_1_1_task_graph_communicator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_task_graph_communicator_8hpp_source.html">htgs/core/comm/TaskGraphCommunicator.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for htgs::TaskGraphCommunicator:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_task_graph_communicator__coll__graph.png" border="0" usemap="#htgs_1_1_task_graph_communicator_coll__map" alt="Collaboration graph"/></div>
<map name="htgs_1_1_task_graph_communicator_coll__map" id="htgs_1_1_task_graph_communicator_coll__map">
<area shape="rect" id="node2" href="classhtgs_1_1_blocking_queue.html" title="{htgs::BlockingQueue\l\&lt; std::shared_ptr\&lt; htgs\l::DataPacket \&gt; \&gt;\n|&#45; queueSize\l&#45; mutex\l&#45; condition\l|+ BlockingQueue()\l+ BlockingQueue()\l+ ~BlockingQueue()\l+ remainingCapacity()\l+ isEmpty()\l+ size()\l+ remove()\l+ Enqueue()\l+ Dequeue()\l+ poll()\l}" alt="" coords="17,301,176,569"/>
<area shape="rect" id="node4" title="STL class. " alt="" coords="250,154,330,231"/>
<area shape="rect" id="node5" title="STL class. " alt="" coords="227,5,353,97"/>
<area shape="rect" id="node7" title="STL class. " alt="" coords="524,397,608,474"/>
<area shape="rect" id="node8" title="STL class. " alt="" coords="632,389,769,481"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e2d7c194f9c25836ab191b125d51c13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a3e2d7c194f9c25836ab191b125d51c13">TaskGraphCommunicator</a> (<a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *parent, std::string <a class="el" href="classhtgs_1_1_task_graph_communicator.html#aad666eff18170680f0296cf908c31839">address</a>)</td></tr>
<tr class="memdesc:a3e2d7c194f9c25836ab191b125d51c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the task graph communicator.  <a href="#a3e2d7c194f9c25836ab191b125d51c13">More...</a><br /></td></tr>
<tr class="separator:a3e2d7c194f9c25836ab191b125d51c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad319bc32bb481ed30efa133c472de1e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#ad319bc32bb481ed30efa133c472de1e7">rootSpawnThreads</a> ()</td></tr>
<tr class="memdesc:ad319bc32bb481ed30efa133c472de1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns threads only if the task graph communicator calling this function is the root communicator.  <a href="#ad319bc32bb481ed30efa133c472de1e7">More...</a><br /></td></tr>
<tr class="separator:ad319bc32bb481ed30efa133c472de1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295fb363dcce12a8911cbfce4eed5425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a295fb363dcce12a8911cbfce4eed5425">spawnChildrenThreads</a> ()</td></tr>
<tr class="memdesc:a295fb363dcce12a8911cbfce4eed5425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns the threads for all children communicator.  <a href="#a295fb363dcce12a8911cbfce4eed5425">More...</a><br /></td></tr>
<tr class="separator:a295fb363dcce12a8911cbfce4eed5425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab746a9ae33df0d5a8936515877250e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab746a9ae33df0d5a8936515877250e3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#ab746a9ae33df0d5a8936515877250e3c">spawnThread</a> ()</td></tr>
<tr class="memdesc:ab746a9ae33df0d5a8936515877250e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns the thread for this communicator. <br /></td></tr>
<tr class="separator:ab746a9ae33df0d5a8936515877250e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c19610bb5966553a488782801c860f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a3c19610bb5966553a488782801c860f3">setNumGraphsSpawned</a> (size_t <a class="el" href="classhtgs_1_1_task_graph_communicator.html#ab48ac06c2adc73a6211731d5f3be52be">numGraphsSpawned</a>)</td></tr>
<tr class="memdesc:a3c19610bb5966553a488782801c860f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of graphs spawned.  <a href="#a3c19610bb5966553a488782801c860f3">More...</a><br /></td></tr>
<tr class="separator:a3c19610bb5966553a488782801c860f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e4dad1438c70313f789191ec448685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#ae6e4dad1438c70313f789191ec448685">printParents</a> (std::string prefix)</td></tr>
<tr class="memdesc:ae6e4dad1438c70313f789191ec448685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the address of the parent communicator recursively to std::cout.  <a href="#ae6e4dad1438c70313f789191ec448685">More...</a><br /></td></tr>
<tr class="separator:ae6e4dad1438c70313f789191ec448685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e03bd448e09411634cfd89b8ef48324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a4e03bd448e09411634cfd89b8ef48324">printTree</a> (std::string prefix)</td></tr>
<tr class="memdesc:a4e03bd448e09411634cfd89b8ef48324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the task graph communicator tree recursively to std::cout.  <a href="#a4e03bd448e09411634cfd89b8ef48324">More...</a><br /></td></tr>
<tr class="separator:a4e03bd448e09411634cfd89b8ef48324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e8d3b677fe70448898c0855b4e6b0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a31e8d3b677fe70448898c0855b4e6b0a">getParentComm</a> () const </td></tr>
<tr class="memdesc:a31e8d3b677fe70448898c0855b4e6b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent communicator.  <a href="#a31e8d3b677fe70448898c0855b4e6b0a">More...</a><br /></td></tr>
<tr class="separator:a31e8d3b677fe70448898c0855b4e6b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae4b3a65f50db3eef0dce983df66ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_task_graph_communicator_8hpp.html#a7c59f0f85195e200584af8a02e97d7c9">TaskCommMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#abae4b3a65f50db3eef0dce983df66ae1">getChildren</a> () const </td></tr>
<tr class="memdesc:abae4b3a65f50db3eef0dce983df66ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the children for the task graph communicator.  <a href="#abae4b3a65f50db3eef0dce983df66ae1">More...</a><br /></td></tr>
<tr class="separator:abae4b3a65f50db3eef0dce983df66ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bcb15d176dfe295d8238d8a7cc67f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a61bcb15d176dfe295d8238d8a7cc67f8">checkRootSpawnThreads</a> ()</td></tr>
<tr class="memdesc:a61bcb15d176dfe295d8238d8a7cc67f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the root can spawn threads yet or not.  <a href="#a61bcb15d176dfe295d8238d8a7cc67f8">More...</a><br /></td></tr>
<tr class="separator:a61bcb15d176dfe295d8238d8a7cc67f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d306262f4a7c90f8a8b3e4923fc271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a43d306262f4a7c90f8a8b3e4923fc271">incrementRootCommunicatorGraphs</a> ()</td></tr>
<tr class="memdesc:a43d306262f4a7c90f8a8b3e4923fc271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the number of graphs received by the root communicator.  <a href="#a43d306262f4a7c90f8a8b3e4923fc271">More...</a><br /></td></tr>
<tr class="separator:a43d306262f4a7c90f8a8b3e4923fc271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43b4f70cf3246dad2b124e0ac61871f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#aa43b4f70cf3246dad2b124e0ac61871f">getRootNumGraphsReceived</a> ()</td></tr>
<tr class="memdesc:aa43b4f70cf3246dad2b124e0ac61871f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of graphs received by the root communicator.  <a href="#aa43b4f70cf3246dad2b124e0ac61871f">More...</a><br /></td></tr>
<tr class="separator:aa43b4f70cf3246dad2b124e0ac61871f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281a55015233f4e26aca398c76b620c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a281a55015233f4e26aca398c76b620c8">getRootTotalSubGraphsSpawned</a> ()</td></tr>
<tr class="memdesc:a281a55015233f4e26aca398c76b620c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of graphs spawned by the root communicator.  <a href="#a281a55015233f4e26aca398c76b620c8">More...</a><br /></td></tr>
<tr class="separator:a281a55015233f4e26aca398c76b620c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc467f0ab16e5cbc8b58759c102e3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#affc467f0ab16e5cbc8b58759c102e3f5">processFlattenTaskNameConnectorMap</a> (std::shared_ptr&lt; std::unordered_multimap&lt; std::string, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&gt;&gt; <a class="el" href="classhtgs_1_1_task_graph_communicator.html#adf0fb6869ea68d39147f205998273ad7">flattenedTaskNameConnectorMap</a>)</td></tr>
<tr class="memdesc:affc467f0ab16e5cbc8b58759c102e3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the mapping between the addresses and task manager names and their connnectors.  <a href="#affc467f0ab16e5cbc8b58759c102e3f5">More...</a><br /></td></tr>
<tr class="separator:affc467f0ab16e5cbc8b58759c102e3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a72607eaa8b546c25867d946ba07c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a5a72607eaa8b546c25867d946ba07c02">addTaskNameConnectorMap</a> (std::unordered_multimap&lt; std::string, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&gt; *o)</td></tr>
<tr class="memdesc:a5a72607eaa8b546c25867d946ba07c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the mapping between a task's address and its name to the input connector for that task.  <a href="#a5a72607eaa8b546c25867d946ba07c02">More...</a><br /></td></tr>
<tr class="separator:a5a72607eaa8b546c25867d946ba07c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea46482827c460c7499d198befd9dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a2ea46482827c460c7499d198befd9dec">addChild</a> (<a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *comm)</td></tr>
<tr class="memdesc:a2ea46482827c460c7499d198befd9dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child communicator for this task graph communicator.  <a href="#a2ea46482827c460c7499d198befd9dec">More...</a><br /></td></tr>
<tr class="separator:a2ea46482827c460c7499d198befd9dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7f3534fd7cdcb5b11fe253a3977e75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#acc7f3534fd7cdcb5b11fe253a3977e75">getAddress</a> () const </td></tr>
<tr class="memdesc:acc7f3534fd7cdcb5b11fe253a3977e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the task graph communicator.  <a href="#acc7f3534fd7cdcb5b11fe253a3977e75">More...</a><br /></td></tr>
<tr class="separator:acc7f3534fd7cdcb5b11fe253a3977e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066c52c0bf8d1199342bac4c44fa9fd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a066c52c0bf8d1199342bac4c44fa9fd5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a066c52c0bf8d1199342bac4c44fa9fd5">terminateGracefully</a> ()</td></tr>
<tr class="memdesc:a066c52c0bf8d1199342bac4c44fa9fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gracefully terminates the task graph communicator thread. <br /></td></tr>
<tr class="separator:a066c52c0bf8d1199342bac4c44fa9fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a6b8fdd0e01948ac65a338a6f5edb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3a6b8fdd0e01948ac65a338a6f5edb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#af3a6b8fdd0e01948ac65a338a6f5edb8">run</a> ()</td></tr>
<tr class="memdesc:af3a6b8fdd0e01948ac65a338a6f5edb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main run function for the thread, which processes data packets until it is terminated. <br /></td></tr>
<tr class="separator:af3a6b8fdd0e01948ac65a338a6f5edb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb4da0a89bf85675bd48bb3f0845f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#acdb4da0a89bf85675bd48bb3f0845f01">produceDataPacket</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_data_packet.html">DataPacket</a> &gt; data)</td></tr>
<tr class="memdesc:acdb4da0a89bf85675bd48bb3f0845f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces data packet to be processed for the task graph communicator.  <a href="#acdb4da0a89bf85675bd48bb3f0845f01">More...</a><br /></td></tr>
<tr class="separator:acdb4da0a89bf85675bd48bb3f0845f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397bdb0aa3b8ac823c38ea78009516a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a397bdb0aa3b8ac823c38ea78009516a4">processDataPacket</a> ()</td></tr>
<tr class="memdesc:a397bdb0aa3b8ac823c38ea78009516a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes one data packet.  <a href="#a397bdb0aa3b8ac823c38ea78009516a4">More...</a><br /></td></tr>
<tr class="separator:a397bdb0aa3b8ac823c38ea78009516a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b48123b40a7aa22931174411d6aaa96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a2b48123b40a7aa22931174411d6aaa96">isTerminated</a> ()</td></tr>
<tr class="memdesc:a2b48123b40a7aa22931174411d6aaa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the task communicator is terminated or not.  <a href="#a2b48123b40a7aa22931174411d6aaa96">More...</a><br /></td></tr>
<tr class="separator:a2b48123b40a7aa22931174411d6aaa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a073ec88650dab2b9d255002f2cb108f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a073ec88650dab2b9d255002f2cb108f1"></a>
std::unordered_multimap&lt; std::string, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a073ec88650dab2b9d255002f2cb108f1">taskNameConnectorMap</a></td></tr>
<tr class="memdesc:a073ec88650dab2b9d255002f2cb108f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local mapping between the task graph communicator and its task graph. <br /></td></tr>
<tr class="separator:a073ec88650dab2b9d255002f2cb108f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0fb6869ea68d39147f205998273ad7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf0fb6869ea68d39147f205998273ad7"></a>
std::shared_ptr&lt; std::unordered_multimap&lt; std::string, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#adf0fb6869ea68d39147f205998273ad7">flattenedTaskNameConnectorMap</a></td></tr>
<tr class="memdesc:adf0fb6869ea68d39147f205998273ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flattened mapping shared between all task graph communicators. <br /></td></tr>
<tr class="separator:adf0fb6869ea68d39147f205998273ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2f5c2927f968725723a9c080f6891d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed2f5c2927f968725723a9c080f6891d"></a>
<a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#aed2f5c2927f968725723a9c080f6891d">parentComm</a></td></tr>
<tr class="memdesc:aed2f5c2927f968725723a9c080f6891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The parent communicator (or nullptr if this is the root communicator). <br /></td></tr>
<tr class="separator:aed2f5c2927f968725723a9c080f6891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad666eff18170680f0296cf908c31839"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad666eff18170680f0296cf908c31839"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#aad666eff18170680f0296cf908c31839">address</a></td></tr>
<tr class="memdesc:aad666eff18170680f0296cf908c31839"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address of the communicator. <br /></td></tr>
<tr class="separator:aad666eff18170680f0296cf908c31839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48ac06c2adc73a6211731d5f3be52be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab48ac06c2adc73a6211731d5f3be52be"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#ab48ac06c2adc73a6211731d5f3be52be">numGraphsSpawned</a></td></tr>
<tr class="memdesc:ab48ac06c2adc73a6211731d5f3be52be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of graphs spawned. <br /></td></tr>
<tr class="separator:ab48ac06c2adc73a6211731d5f3be52be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b8f7818747f5696e5e5a4ac62658ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b8f7818747f5696e5e5a4ac62658ec"></a>
std::atomic_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a96b8f7818747f5696e5e5a4ac62658ec">numGraphsReceived</a></td></tr>
<tr class="memdesc:a96b8f7818747f5696e5e5a4ac62658ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of graphs received. <br /></td></tr>
<tr class="separator:a96b8f7818747f5696e5e5a4ac62658ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab7673355ce07ae2461d8c11bc80f3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab7673355ce07ae2461d8c11bc80f3a"></a>
<a class="el" href="_task_graph_communicator_8hpp.html#a7c59f0f85195e200584af8a02e97d7c9">TaskCommMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a0ab7673355ce07ae2461d8c11bc80f3a">children</a></td></tr>
<tr class="memdesc:a0ab7673355ce07ae2461d8c11bc80f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The children communicator. <br /></td></tr>
<tr class="separator:a0ab7673355ce07ae2461d8c11bc80f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d9b7df0c63fa749850ab5dbef7aa8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53d9b7df0c63fa749850ab5dbef7aa8a"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a53d9b7df0c63fa749850ab5dbef7aa8a">mutex</a></td></tr>
<tr class="memdesc:a53d9b7df0c63fa749850ab5dbef7aa8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex used to ensure thread safety. <br /></td></tr>
<tr class="separator:a53d9b7df0c63fa749850ab5dbef7aa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356754ff924d43816daa2b515c90d06d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a356754ff924d43816daa2b515c90d06d"></a>
<a class="el" href="classhtgs_1_1_blocking_queue.html">BlockingQueue</a>&lt; std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_data_packet.html">DataPacket</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a356754ff924d43816daa2b515c90d06d">dataQueue</a></td></tr>
<tr class="memdesc:a356754ff924d43816daa2b515c90d06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data queue to hold data packets. <br /></td></tr>
<tr class="separator:a356754ff924d43816daa2b515c90d06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abece203e04aefce9e139499fc949d781"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abece203e04aefce9e139499fc949d781"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#abece203e04aefce9e139499fc949d781">terminated</a></td></tr>
<tr class="memdesc:abece203e04aefce9e139499fc949d781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used to indicate if the communicator is terminated or not. <br /></td></tr>
<tr class="separator:abece203e04aefce9e139499fc949d781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162a3ef8e3fecb8b09054e705e024b79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a162a3ef8e3fecb8b09054e705e024b79"></a>
std::thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_communicator.html#a162a3ef8e3fecb8b09054e705e024b79">thread</a></td></tr>
<tr class="memdesc:a162a3ef8e3fecb8b09054e705e024b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">The communicator thread. <br /></td></tr>
<tr class="separator:a162a3ef8e3fecb8b09054e705e024b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the task graph communicator where a task's address and name are mapped to their input connectors. </p>
<p>This class's run function is bound to a thread once all task graphs (including sub-graphs), have been built and spawned. Once all threads are active, then a thread is bound to the task graph communicator. All graphs within execution pipelines and the main root graph have a separate task graph communicator, but share the task address mapping.</p>
<p>Initially the main graph represents the root of a tree of graphs with branches being defined by execution pipelines. Once all threads and execution pipelines have been created, then the root task graph communicator gathers all addresses and creates the mapping. Once the mapping is complete, then all task graph communicators are bound to separate threads. The mapping is read-only at this point.</p>
<p>Each task can submit a data packet into the task graph communicator, which will then send the data directly into the input connector for that data packet's destination.</p>
<p>A <a class="el" href="classhtgs_1_1_data_packet.html" title="Implements a data packet that is transmitted to the TaskGraphCommunicator. ">DataPacket</a> is inserted into the task graph communicator, which provides meta data for looking up the end point location for the data packet. The data packet holds <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>, which is then inserted into the end point's input connector.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a> type must match the end point input connector's data type. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3e2d7c194f9c25836ab191b125d51c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">htgs::TaskGraphCommunicator::TaskGraphCommunicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the task graph communicator. </p>
<p>If the parent specified is nullptr, then this instance is the root communicator within a tree of communicators. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent communicator or nullptr if this communicator is the root </td></tr>
    <tr><td class="paramname">address</td><td>the address that this task graph communicator represents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2ea46482827c460c7499d198befd9dec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child communicator for this task graph communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>the child communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a72607eaa8b546c25867d946ba07c02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::addTaskNameConnectorMap </td>
          <td>(</td>
          <td class="paramtype">std::unordered_multimap&lt; std::string, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&gt; *&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the mapping between a task's address and its name to the input connector for that task. </p>
<p>This will add all of these mappings to this task graph communicator. After which the parent communicator increments the number of communicator graphs. If this is called by the parent communicator, then it will check if it is ready to spawn threads</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61bcb15d176dfe295d8238d8a7cc67f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::checkRootSpawnThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the root can spawn threads yet or not. </p>
<p>This function will recursively be called until it reaches the root communicator. The root communicator will then verify if the number of graphs received is equal to the number of graphs spawned. If they are equal, then all of the threads will be initiated. Doing so ensures all tasks and sub-graphs have completed spawning and the mapping between all tasks in the graph has been completed. </p>

</div>
</div>
<a class="anchor" id="acc7f3534fd7cdcb5b11fe253a3977e75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string htgs::TaskGraphCommunicator::getAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the address of the task graph communicator. </p>
<p>This matches the address of the task graph that owns the communicator. </p><dl class="section return"><dt>Returns</dt><dd>the address </dd></dl>

</div>
</div>
<a class="anchor" id="abae4b3a65f50db3eef0dce983df66ae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_task_graph_communicator_8hpp.html#a7c59f0f85195e200584af8a02e97d7c9">TaskCommMap</a>* htgs::TaskGraphCommunicator::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the children for the task graph communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>the children </dd></dl>

</div>
</div>
<a class="anchor" id="a31e8d3b677fe70448898c0855b4e6b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a>* htgs::TaskGraphCommunicator::getParentComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the parent communicator. </p>
<dl class="section return"><dt>Returns</dt><dd>the parent communicator </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the parent communicator is nullptr, then that communicator is the root. </dd></dl>

</div>
</div>
<a class="anchor" id="aa43b4f70cf3246dad2b124e0ac61871f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t htgs::TaskGraphCommunicator::getRootNumGraphsReceived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of graphs received by the root communicator. </p>
<p>This function is called recursively until the root is reached.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of graphs received by the root communicator </dd></dl>

</div>
</div>
<a class="anchor" id="a281a55015233f4e26aca398c76b620c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t htgs::TaskGraphCommunicator::getRootTotalSubGraphsSpawned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of graphs spawned by the root communicator. </p>
<p>This function is called recursively until the root is reached</p>
<dl class="section return"><dt>Returns</dt><dd>the number of graphs spawned by the root communicator </dd></dl>

</div>
</div>
<a class="anchor" id="a43d306262f4a7c90f8a8b3e4923fc271"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::incrementRootCommunicatorGraphs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the number of graphs received by the root communicator. </p>
<p>This function is called recursively, and only the root communicator is incremented. </p>

</div>
</div>
<a class="anchor" id="a2b48123b40a7aa22931174411d6aaa96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool htgs::TaskGraphCommunicator::isTerminated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the task communicator is terminated or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the communicator is terminated, otherwise false </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the communicator is terminated </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the communicator is not terminated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6e4dad1438c70313f789191ec448685"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::printParents </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the address of the parent communicator recursively to std::cout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>the prefix for printing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e03bd448e09411634cfd89b8ef48324"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::printTree </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the task graph communicator tree recursively to std::cout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>the prefix for printing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a397bdb0aa3b8ac823c38ea78009516a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::processDataPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes one data packet. </p>
<p>If the data packet is nullptr, then the thread will be terminated.</p>
<p>If there are multiple entries that share the same address and task name, then an error is produced. Every task must have a unique name if the communicator is to be used. </p>

</div>
</div>
<a class="anchor" id="affc467f0ab16e5cbc8b58759c102e3f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::processFlattenTaskNameConnectorMap </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; std::unordered_multimap&lt; std::string, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>flattenedTaskNameConnectorMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flattens the mapping between the addresses and task manager names and their connnectors. </p>
<p>Doing so allows for constant time look-up for the address to task name connectors </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flattenedTaskNameConnectorMap</td><td>the mapping between the address and manager names to their connects, which is shared among all communicators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is called prior to spawning threads for the task graph communicators </dd></dl>

</div>
</div>
<a class="anchor" id="acdb4da0a89bf85675bd48bb3f0845f01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::produceDataPacket </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_data_packet.html">DataPacket</a> &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces data packet to be processed for the task graph communicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="ad319bc32bb481ed30efa133c472de1e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::rootSpawnThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spawns threads only if the task graph communicator calling this function is the root communicator. </p>
<dl class="section note"><dt>Note</dt><dd>If the parent communicator is nullptr, then that instance is the root. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c19610bb5966553a488782801c860f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::setNumGraphsSpawned </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numGraphsSpawned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of graphs spawned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGraphsSpawned</td><td>the number of graphs spawned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a295fb363dcce12a8911cbfce4eed5425"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void htgs::TaskGraphCommunicator::spawnChildrenThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Spawns the threads for all children communicator. </p>
<dl class="section note"><dt>Note</dt><dd>this function is only called by the parent communicator. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/tjb3/phd-research/HTGS/src/htgs/core/comm/<a class="el" href="_task_graph_communicator_8hpp_source.html">TaskGraphCommunicator.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>htgs</b></li><li class="navelem"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
