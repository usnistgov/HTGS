<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HTGS: Tutorial 2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial2.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial 2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#objectives">Objectives </a></li>
<li class="level1"><a href="#api-used">API Used </a></li>
<li class="level1"><a href="#implementation">Implementation </a><ul><li class="level2"><a href="#data">Data</a><ul><li class="level3"><a href="#matrix-request">MatrixRequestData</a></li>
<li class="level3"><a href="#matrix-data">MatrixBlockData</a></li>
<li class="level3"><a href="#matrix-mul-data">MatrixBlockMulData</a></li>
<li class="level3"><a href="#data-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#tasks">Tasks</a><ul><li class="level3"><a href="#read-matrix-task">ReadMatrixTask</a></li>
<li class="level3"><a href="#hadamard-product-task">HadamardProductTask</a></li>
<li class="level3"><a href="#task-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#bookkeeper">Managing Dependencies with a Bookkeeper and IRules</a><ul><li class="level3"><a href="#bookkeeper-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#memory-manager">Throttling Tasks with a Memory Manager</a><ul><li class="level3"><a href="#static-mm">Static Memory Manager</a></li>
<li class="level3"><a href="#dynamic-mm">Dynamic Memory Manager</a></li>
<li class="level3"><a href="#user-managed-mm">User Managed Memory Manager</a></li>
<li class="level3"><a href="#memorymanagement-notes">Notes</a></li>
</ul>
</li>
<li class="level2"><a href="#create-and-execute-taskgraph">Creating and Executing the TaskGraph</a><ul><li class="level3"><a href="#main-function">Main function (Hadamard Product)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>In this tutorial we will be introducing two components of HTGS: (1) How to representing algorithms with dependencies and (2) How to stay within memory limits.</p>
<p>The source code for the tutorial is found in "test/tutorial2"</p>
<p>To demonstrate these capabilities, we will be implementing the Hadamard product between two matrices of equal size. There are three attributes to keep an eye out for. First, transforming an algorithm's representation to enable better pipelining and parallelism, second, adding memory edges to ensure the graph will not use all of the available system memory, and third, how to represent a dependency to ensure data is loaded prior to execution.</p>
<h1><a class="anchor" id="objectives"></a>
Objectives </h1>
<ol type="1">
<li>How to encapsulate IData objects</li>
<li>How to use local variables in ITasks</li>
<li>How to exploit algorithm parallelism<ul>
<li>Transforming the algorithm into independent parts (i.e. block decomposition)</li>
<li>Creating thread pools based on compute needs</li>
</ul>
</li>
<li>How to pipeline tasks<ul>
<li>With the goal of overlapping I/O with compute</li>
</ul>
</li>
<li>How to manage dependencies</li>
<li>How to manage memory<ul>
<li>Using a static memory manager</li>
<li>Using a user-managed memory manager</li>
</ul>
</li>
<li>How to handle memory between a TaskGraph's task and the main thread</li>
</ol>
<h1><a class="anchor" id="api-used"></a>
API Used </h1>
<ul>
<li>&lt;<a class="el" href="_i_data_8hpp.html" title="Implements the IData class, which is used for all data types entering/leaving a task graph...">htgs/api/IData.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_task_8hpp.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs/api/ITask.hpp</a>&gt;</li>
<li>&lt;htgs/api/TaskGraph.hpp&gt;</li>
<li>&lt;htgs/api/Runtime.hpp&gt;</li>
<li>&lt;<a class="el" href="_memory_data_8hpp.html" title="Implements MemoryData used by a MemoryManager, which can be shared among multiple ITask...">htgs/api/MemoryData.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_memory_allocator_8hpp.html" title="Defines how memory is allocated and freed. ">htgs/api/IMemoryAllocator.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_memory_release_rule_8hpp.html" title="Describes how memory is released. ">htgs/api/IMemoryReleaseRule.hpp</a>&gt;</li>
<li>&lt;<a class="el" href="_i_rule_8hpp.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs/api/IRule.hpp</a>&gt;</li>
</ul>
<h1><a class="anchor" id="implementation"></a>
Implementation </h1>
<p>Below we analyze the various components used in defining the Hadamard product algorithm. First, we will present the algorithm, then transform the algorithm into a dataflow graph. Finally the dataflow graph is altered into a TaskGraph.</p>
<p>The basic representation of the Hadamard algorithm is <img class="formulaInl" alt="$A \circ B = C$" src="form_1.png"/>, which computes the element-wise matrix multiplication between two matrices that share the same dimensions.</p>
<p>Pseudo code: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Given matrices A and B, each with the same dimensions</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;for_each(row) {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  for_each(col) {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    C[row][col] = A[row][col] * B[row][col];</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  }</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div></div><!-- fragment --><p>One goal of HTGS is to exploit parallelism and aid in orchestrating pipeline workflows. In order to represent an algorithm to exploit these components, we must understand the parallelism of the Hadamard product.</p>
<p>One thing that is clear is each loop iteration can be done in parallel, such that threads can process each element of C in parallel without any need for synchronization. When initiating these computations in a TaskGraph there is some overhead with sending data between tasks and allocating data. Therefore, the best method for processing the Hadamard product is to decompose the matrices into blocks and have each thread compute a Hadamard product on the matching row, column matrix blocks. Below is a figure demonstrating the block decomposition of the Hadamard Product.</p>
<div class="image">
<img src="figures/hadamardProductFigure.png"  alt="Block Size Impact" style="width: 35%;"/>
</div>
<p>Given the block decomposition variation of the algorithm, we transform the Hadamard product into a dataflow graph. For this implementation we assume the data has been saved to disk and distributed into separate files, where each file represents a block of either matrix A or matrix B. A sample dataset can be downloaded from (link to dataset). Datasets can be generated using the test/matrix-ops/testScalarMultiply.</p>
<p>Dataflow graph:</p>
<div class="image">
<img src="figures/tut2Hadamard-dataflow.png"  style="width: 45%;"/>
</div>
<p>TaskGraph:</p>
<div class="image">
<img src="figures/tut2Hadamard-taskgraph.png"  style="width: 80%;"/>
</div>
<p>Using the dataflow graph, we analyze the various data requirements that need to be created for the TaskGraph. First, we need a data object to represent block read requests. The block read request should request the row, column block that is to be read. Next, there are two reads required to compute one Hadamard product task, so a data object to encapsulate both reads into a single object, which stores each matrix will be needed. Finally, the result of the Hadamard product produces a block of data that represents matrix C's sub-matrix.</p>
<p>Comparing the TaskGraph and dataflow representations, we merged the two read functions into a single read task. A flag within block request data can indicate whether to read from matrix A or B. Merging the two read functions is not required, and we could represent two separate read tasks for matrices A and B. One important component of HTGS is the input of a TaskGraph can only feed data to one Task. Therefore, if we were to separate the read into two Tasks, we would need a Bookkeeper to distribute the block requests between the two readers. In the next tutorial, we will demonstrate this concept.</p>
<p>After reading data, a block of matrix data is then sent into a bookkeeper. The bookkeeper is used to manage programmer-defined rules that are synchronously accessed to manage the state of the computation and satisfy algorithmic data dependencies. In this example, we use a LoadRule to keep track of what blocks of matrices A and B have been loaded. When a matching row, column of both matrices are loaded, then the rule will produce data for the Hadamard product task.</p>
<p>Every task in this TaskGraph can have one or more threads processing data. This allows the read task to pipeline with the Hadamard product task, overlapping the I/O of reading a matrix block with computing the Hadamard product of two blocks. There are two important concerns with this design. First, what is the ideal block size to use and second, what if the matrix being operated on cannot fit into memory.</p>
<p>For determining the block size, we need to understand two performance attributes of HTGS. First, there is a small overhead involved with passing data between tasks, and second, we want to have enough data flowing in the task graph to enable pipelining. To demonstrate these components, below is a plot showing the impact of block size versus runtime. The source code that generated this plot can be found in "tests/tutorial2-a". Note: In this example we altered the read task to generate the matrix, which eliminated some uncertainty with disk read I/O. We repeated the experiment 5 times for each block size and reported the average runtime.</p>
<div class="image">
<img src="figures/blocksize-impact.png"  alt="Block Size Impact" style="width: 40%;"/>
</div>
<p>In the graph, we see that there is a penalty incurred with small block sizes. This is attributed to data overwhelming the FIFO queues and not enough computation per data element sent to the Hadamard task. Increasing the block size improves the runtime, but if the block size becomes too large (such as the size of the entire matrix), then the TaskGraph does not benefit from pipelining.</p>
<p>The other concern involves memory limitations. As each task executes, there is no throttling between tasks, so it is possible that one task could allocate data faster than another task can process data. Using a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a>, we can connect two tasks with a memory edge to allow one task to throttle another task. The role of the MemoryManager is to allocate, free, recycle, and update the state of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a>. The MemoryManager is connected to two task's by using the htgs::TaskGraph::addMemoryManagerEdge function. This function specifies one task is requesting(getting) memory, and the other task is releasing memory. There is a memory pool associated with the memory manager, therefore if the memory pool is empty, then any task requesting memory will block and wait. The MemoryData will only be added back into the memory pool based on user-defined memory release rules. These rules are synchronously accessed by the MemoryManager and update the state of the memory, which should ultimately allow the memory to be released. If the memory release rule does not follow the data schedule, then it is possible for a TaskGraph to deadlock.</p>
<p>The figure below shows the TaskGraph annotated with memory edges. We will discuss the <a href="#memory-manager">memory manager implementation</a> in more detail in a later section.</p>
<div class="image">
<img src="figures/tut2Hadamard-taskgraph-memory.png"  style="width: 90%;"/>
</div>
<p>In the annotated TaskGraph, we connect two memory edges (for matrices A and B) between the read and Hadamard product tasks. Using these edges, the Hadamard product task can throttle the reader. We connect one addition edge to the Hadamard product task, which is released by the main thread. This connection allows the Hadamard product task to be throttled by the main thread, which is useful if the post-processing computation cannot keep up with the data production rate of the Hadamard product task.</p>
<p>In the next sections, we implement each of the components for the TaskGraph using HTGS.</p>
<h2><a class="anchor" id="data"></a>
Data</h2>
<p>There are three types of data that must be represented for the Hadamard product algorithm's TaskGraph. First, MatrixRequestData requests a particular row, column block to be read from disk. The read Task will produce MatrixBlockData that contains the matrix data that was read and the request. Finally, when two MatrixBlockData's that are within the same row, column have been loaded, then the LoadRule will produce the pair of blocks to the Hadamard Product task. We store these blocks in MatrixBlockMulData.</p>
<p>In this implementation, we use a variety of methods for encapsulating and reusing data objects. For example, the MatrixBlockData holds onto the MatrixRequestData as well as MemoryData that is sent from the MemoryManager. The MatrixBlockMulData, holds two instances of MatrixBlockData, one for matrix A and the other for matrix B. Encapsulating the data across objects that pass from task to task reduces code size, while holding onto the metadata that is needed to compute the algorithm.</p>
<p>We also templatized the MatrixBlockData so we can represent multiple types of data to further reduce code size. In this particular case, the read task is producing MatrixBlockData that holds MemoryData&lt;double *&gt;. Whereas, the Hadamard product task is producing double * data. By representing MatrixBlockData with a template, we are able to define multiple types for a single data object implementation. When connecting two tasks that use templatized data, the input and output types of the connected tasks must have the same template type.</p>
<p>For tasks that have a memory manager edge attached to them, it is important to pass the shared pointer that is aquired from the memory edge to the task that will be releasing that memory. This can be done by representing the shared pointer within the data.</p>
<h3><a class="anchor" id="matrix-request"></a>
MatrixRequestData</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div><div class="line"><span class="keyword">enum class</span> MatrixType {</div><div class="line">  MatrixA,</div><div class="line">  MatrixB,</div><div class="line">  MatrixC</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>MatrixRequestData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a> {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatrixRequestData(<span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col, MatrixType type) : row(row), col(col), type(type) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> getRow()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> row;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> getCol()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> col;</div><div class="line">  }</div><div class="line">  MatrixType getType()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> type;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> row;</div><div class="line">  <span class="keywordtype">int</span> col;</div><div class="line">  MatrixType type;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="matrix-data"></a>
MatrixBlockData</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_memory_data_8hpp.html">htgs/api/MemoryData.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;htgs::MemoryData&lt;double *&gt;&gt; MatrixMemoryData_t;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class </span>MatrixBlockData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a></div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  MatrixBlockData(<span class="keyword">const</span> std::shared_ptr&lt;MatrixRequestData&gt; &amp;request,</div><div class="line">                  <span class="keyword">const</span> T &amp;matrixData,</div><div class="line">                  <span class="keywordtype">int</span> matrixWidth,</div><div class="line">                  <span class="keywordtype">int</span> matrixHeight) :</div><div class="line">  request(request), matrixData(matrixData), matrixWidth(matrixWidth), matrixHeight(matrixHeight) { }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;MatrixRequestData&gt; &amp;getRequest()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> request;</div><div class="line">  }</div><div class="line">  <span class="keyword">const</span> T &amp;getMatrixData()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixData;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> getMatrixWidth()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixWidth;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> getMatrixHeight()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixHeight;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::shared_ptr&lt;MatrixRequestData&gt; request;</div><div class="line">  T matrixData;</div><div class="line">  <span class="keywordtype">int</span> matrixWidth;</div><div class="line">  <span class="keywordtype">int</span> matrixHeight;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="matrix-mul-data"></a>
MatrixBlockMulData</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_data_8hpp.html">htgs/api/IData.hpp</a>&gt;</span></div><div class="line"><span class="keyword">class </span>MatrixBlockMulData : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_data.html">htgs::IData</a> {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line"></div><div class="line">  MatrixBlockMulData(<span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt; &amp;matrixA, <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt; &amp;matrixB) :</div><div class="line">  matrixA(matrixA), matrixB(matrixB) { }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt; &amp;getMatrixA()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixA;</div><div class="line">  }</div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt; &amp;getMatrixB()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> matrixB;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt; matrixA;</div><div class="line">  std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt; matrixB;</div><div class="line">};</div></div><!-- fragment --> <h3><a class="anchor" id="data-notes"></a>
Notes</h3>
<ul>
<li>IData can represent a wide variety of data<ul>
<li>Encapsulating multiple IData objects into a single IData object</li>
<li>Templatizing IData</li>
</ul>
</li>
<li>MemoryData that is allocated from an ITask should be passed within IData to the ITask that is responsible for releasing that MemoryData</li>
<li>Enums stored in IData can be used to switch between various operations for an ITask</li>
</ul>
<h2><a class="anchor" id="tasks"></a>
Tasks</h2>
<p>For the Hadamard product algorithm, we need to implement two ITasks: Read and Hadamard product.</p>
<p>The ReadMatrixTask is responsible for reading matrices A or B depending on the type of MatrixRequestData passed to the read task. The matrix data is saved to disk such that each block is its own file. If a new block size is specified, then the matrix data will have to be regenerated. There are multiple techniques for reading blocks of data, such as using memory mapped files. With this approach we ensure that each file is accessed by a separate thread. In the next tutorial, we will show multiple variations of this such as using memory mapped files for I/O. The directory structure for the data is stored as follows: "data/tutorial2/4096x4096blksize1024/matrix&lt;A/B&gt;". Prior to reading data from disk, the ReadTask must allocate the memory needed for storing the data. This memory is acquired from the memory edge from either matrixA or matrixB MemoryManagers. To get memory from the memory manager, we use the htgs::ITask::memGet function. If an ITask calls memGet and it was not declared the memory getter for the MemoryManager edge, then the program will report an assertion failed or segementation fault. To check if a memory edge exists use the htgs::ITask::hasMemGetter function.</p>
<p>The HadamardProductTask is responsible for the scalar product of two matrices. These matrices are stored in the MatrixBlockMulData object. Prior to multiplying the matrices, the HadamardProductTask needs to allocate memory for the resulting matrix, which will be added to the output of the TaskGraph. In this implementation we will demonstrate the user-managed memory manager. The various types and functionality of the memory managers is described in the <a href="#memory-manager">MemoryManager</a> section. After the task has completed multiplying matrices A and B together, the Hadamard task must release the memory for matrices A and B so that the memory manager can recycle their pointers for the read task. To release memory use the htgs::ITask::memRelease function. As described for memGet, if the ITask calls memRelease and it was not declared the memory releaser for the MemoryManager edge, then the program will report an assertion failed or segmentation fault. To check if a memory release edge exists use htgs::ITask::hasMemReleaser.</p>
<p>Each of the tasks within a TaskGraph have at least one thread responsible for executing their functionality. The ITask(numThreads) constructor is used to specify the number of threads for an ITask. The Runtime uses this parameter to create copies of the ITask and bind each copy to separate TaskSchedulers, which is then bound to separate threads. Each TaskScheduler shares the same input and output Connectors, which have thread safe blocking queues. Therefore, when data enters a connector, one of the TaskSchedulers waiting for that data will wake up and begin processing the data.</p>
<h3><a class="anchor" id="read-matrix-task"></a>
ReadMatrixTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../memory/MatrixMemoryRule.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>ReadMatrixTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixRequestData, MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt;</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  ReadMatrixTask(<span class="keywordtype">int</span> numThreads, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">int</span> fullMatrixWidth, <span class="keywordtype">int</span> fullMatrixHeight, std::string directory) :</div><div class="line">      ITask(numThreads), blockSize(blockSize), fullMatrixHeight(fullMatrixHeight), fullMatrixWidth(fullMatrixWidth), directory(directory)</div><div class="line">  {</div><div class="line">    numBlocksRows = (int)ceil((<span class="keywordtype">double</span>)fullMatrixHeight / (double)blockSize);</div><div class="line">    numBlocksCols = (int)ceil((<span class="keywordtype">double</span>)fullMatrixWidth / (double)blockSize);</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> ~GenMatrixTask() { }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#af897c3050091c42e9afd364ac25c8eb6">initialize</a>(<span class="keywordtype">int</span> pipelineId, <span class="keywordtype">int</span> numPipelines) { }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#acad9dd61bff4a2d2f96bbb4532a3bb82">shutdown</a>() { }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixRequestData&gt; data) {</div><div class="line">    std::string matrixName;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (data-&gt;getType())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixA: matrixName = <span class="stringliteral">&quot;matrixA&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixB: matrixName = <span class="stringliteral">&quot;matrixB&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixC: <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    MatrixMemoryData_t matrixData = this-&gt;memGet&lt;double *&gt;(matrixName, <span class="keyword">new</span> MatrixMemoryRule(1));</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> row = data-&gt;getRow();</div><div class="line">    <span class="keywordtype">int</span> col = data-&gt;getCol();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> matrixWidth;</div><div class="line">    <span class="keywordtype">int</span> matrixHeight;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (col == numBlocksCols-1 &amp;&amp; fullMatrixWidth % blockSize != 0)</div><div class="line">      matrixWidth = fullMatrixWidth % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixWidth = blockSize;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (row == numBlocksRows-1 &amp;&amp; fullMatrixHeight % blockSize != 0)</div><div class="line">      matrixHeight = fullMatrixHeight % blockSize;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      matrixHeight = blockSize;</div><div class="line"></div><div class="line">    std::string fileName(directory + <span class="stringliteral">&quot;/&quot;</span> + matrixName + <span class="stringliteral">&quot;/&quot;</span> + std::to_string(row) + <span class="stringliteral">&quot;_&quot;</span> + std::to_string(col));</div><div class="line"></div><div class="line">    <span class="comment">// Read data</span></div><div class="line">    std::ifstream file(fileName, std::ios::binary);</div><div class="line"></div><div class="line">    file.read((<span class="keywordtype">char</span> *)matrixData-&gt;get(), <span class="keyword">sizeof</span>(double) * matrixWidth * matrixHeight);</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;MatrixMemoryData_t&gt;(data, matrixData, matrixWidth, matrixHeight));</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;ReadMatrixTask&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask&lt;MatrixRequestData, MatrixBlockData&lt;MatrixMemoryData_t&gt;</a>&gt; *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ReadMatrixTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a35a98bd2bfb55ddffe8f0d01faa3354b">getNumThreads</a>(), blockSize, fullMatrixWidth, fullMatrixHeight, directory);</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isTerminated(std::shared_ptr&lt;htgs::BaseConnector&gt; inputConnector) {</div><div class="line">    <span class="keywordflow">return</span> inputConnector-&gt;isInputTerminated();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> getNumBlocksRows()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksRows;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> getNumBlocksCols()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> numBlocksCols;</div><div class="line">  }</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> blockSize;</div><div class="line">  <span class="keywordtype">int</span> fullMatrixWidth;</div><div class="line">  <span class="keywordtype">int</span> fullMatrixHeight;</div><div class="line">  <span class="keywordtype">int</span> numBlocksRows;</div><div class="line">  <span class="keywordtype">int</span> numBlocksCols;</div><div class="line">  std::string directory;</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="hadamard-product-task"></a>
HadamardProductTask</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../data/MatrixBlockMulData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_task_8hpp.html">htgs/api/ITask.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>HadamardProductTask : <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask</a>&lt;MatrixBlockMulData, MatrixBlockData&lt;double *&gt;&gt;</div><div class="line">{</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  HadamardProductTask(<span class="keywordtype">int</span> numThreads) : ITask(numThreads) {}</div><div class="line">  <span class="keyword">virtual</span> ~HadamardProductTask() { }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#af897c3050091c42e9afd364ac25c8eb6">initialize</a>(<span class="keywordtype">int</span> pipelineId, <span class="keywordtype">int</span> numPipelines) { }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#acad9dd61bff4a2d2f96bbb4532a3bb82">shutdown</a>() { }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_task.html#a78776a659308572e84760e6e36a2520d">executeTask</a>(std::shared_ptr&lt;MatrixBlockMulData&gt; data) {</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matAData = data-&gt;getMatrixA();</div><div class="line">    <span class="keyword">auto</span> matBData = data-&gt;getMatrixB();</div><div class="line"></div><div class="line">    MatrixMemoryData_t matrixA = matAData-&gt;getMatrixData();</div><div class="line">    MatrixMemoryData_t matrixB = matBData-&gt;getMatrixData();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> width = matAData-&gt;getMatrixWidth();</div><div class="line">    <span class="keywordtype">int</span> height = matAData-&gt;getMatrixHeight();</div><div class="line"></div><div class="line">    <span class="comment">// This function will block if memory is not ready to be allocated</span></div><div class="line">    this-&gt;allocUserManagedMemory(<span class="stringliteral">&quot;outputMem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> *result = <span class="keyword">new</span> <span class="keywordtype">double</span>[width*height];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; matAData-&gt;getMatrixWidth() * matAData-&gt;getMatrixHeight(); i++)</div><div class="line">    {</div><div class="line">      result[i] = matrixA-&gt;get()[i] * matrixB-&gt;get()[i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matRequest = matAData-&gt;getRequest();</div><div class="line"></div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt; matReq(<span class="keyword">new</span> MatrixRequestData(matRequest-&gt;getRow(), matRequest-&gt;getCol(), MatrixType::MatrixC));</div><div class="line"></div><div class="line">    <a class="code" href="classhtgs_1_1_i_task.html#a64952b7c68e97d84c97c7b15a0b032aa">addResult</a>(<span class="keyword">new</span> MatrixBlockData&lt;double *&gt;(matReq, result, width, height));</div><div class="line"></div><div class="line">    this-&gt;memRelease(<span class="stringliteral">&quot;matrixA&quot;</span>, matrixA);</div><div class="line">    this-&gt;memRelease(<span class="stringliteral">&quot;matrixB&quot;</span>, matrixB);</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> std::string <a class="code" href="classhtgs_1_1_i_task.html#afe473a9b204654d331f622d1e62af5f2">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;HadamardProductTask&quot;</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classhtgs_1_1_i_task.html">htgs::ITask&lt;MatrixBlockMulData, MatrixBlockData&lt;double *&gt;</a>&gt; *<a class="code" href="classhtgs_1_1_i_task.html#acaedf1466b238036d880efcbf1feafe6">copy</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> HadamardProductTask(this-&gt;<a class="code" href="classhtgs_1_1_any_i_task.html#a35a98bd2bfb55ddffe8f0d01faa3354b">getNumThreads</a>());</div><div class="line">  }</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isTerminated(std::shared_ptr&lt;htgs::BaseConnector&gt; inputConnector) {</div><div class="line">    <span class="keywordflow">return</span> inputConnector-&gt;isInputTerminated();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --> <h3><a class="anchor" id="task-notes"></a>
Notes</h3>
<ul>
<li>Use the htgs::ITask::memGet function to get memory from a memory edge (htgs::ITask::memRelease to release)<ul>
<li>htgs::TaskGraph::addMemoryManagerEdge declares the ITask responsible for getting and releasing memory</li>
<li>If an ITask calls memGet and it is not declared the memory getter from the TaskGraph, then the program will segmentation fault</li>
</ul>
</li>
<li>Specify a pool of threads for an ITask using the ITask(numThreads) constructor</li>
</ul>
<h2><a class="anchor" id="bookkeeper"></a>
Managing Dependencies with a Bookkeeper and IRules</h2>
<p>The <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> is an ITask that is defined with the HTGS API. It is used to manage dependencies, as well as provide a mechanism for branching the flow of data in multiple directions. Each branch from a Bookkeeper can have different output data types. The bookkeeper implements this functionality by using a list of RuleManagers. When data enters a bookkeeper, the data is passed to each <a class="el" href="classhtgs_1_1_rule_manager.html" title="Connects a Bookkeeper to another ITask using one or more IRule(s). ">htgs::RuleManager</a>. The RuleManager is attached to a consumer ITask which will process the output data of the RuleManager. The RuleManager holds onto user-defined <a class="el" href="classhtgs_1_1_i_rule.html">htgs::IRules</a>, which are used to determine whether data entering the RuleManager will pass or create data to the RuleManager's consumer. Each IRule is synchronously accessed using a mutex, such that when an IRule is processing data it is guaranteed that there will be only one thread at a time processing that rule. Because of this attribute, the same IRule instance can be safely shared among multiple Bookkeepers and RuleManagers. This is particularly important for the <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">htgs::ExecutionPipeline</a>, which will create a copy of an entire TaskGraph. We will demonstrate the functionality of ExecutionPipelines in a later tutorial.</p>
<p>Below is a diagram outlining the functionality of the Bookkeeper ITask.</p>
<div class="image">
<img src="figures/taskBookkeeper.png"  style="width: 50%;"/>
</div>
<p>To use the bookkeeper, an <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> must be defined. The IRule represents a rule that processes input and decides when to pass data to an ITask. For the Hadamard product algorithm, we use the MatrixLoadRule to determine when a matching row, column block for both matrices A and B have been loaded. When it detects that the condition is satisfied, then the rule will produce MatrixBlockMulData for the Hadamard task. To add a bookkeeper rule connection to a consumer use the htgs::TaskGraph::addRule function.</p>
<p>The IRule has an input and output type. The input type must match the Bookeeper type and the output type must match the input type of the consumer ITask.</p>
<p>There are three pure virtual functions that define the behavior for each IRule:</p>
<ol type="1">
<li><a class="el" href="classhtgs_1_1_i_rule.html#acf7da2e1b9b25fce31a4dedb34d0df94" title="Virtual function to determine if a rule is ready to be terminated. ">htgs::IRule::canTerminateRule</a><ul>
<li>Determines if the rule is terminated or not. If the RuleManager's input connector is finished producing data, then the IRule will also be terminated. This function is not required to terminate an IRule. When all IRule's for a RuleManager have terminated, the Connector to the consumer ITask is notified.</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html#ab4ce46ea03c5c21db97eb51ae42dbe1b" title="Virtual function that handles when a rule is being shutdown for a particular pipelineId. ">htgs::IRule::shutdownRule</a><ul>
<li>Called when the IRule is terminating. If there is memory allocated for an IRule, that memory should NOT be deallocated in this function. Instead, memory deallocation should take place in the IRule's destructor.</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4" title="Pure virtual function to process input data. ">htgs::IRule::applyRule</a><ul>
<li>Applies the rule on input data. To add data to the consumer ITask attached to the rule, use <a class="el" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2" title="Adds a result value to the output. ">htgs::IRule::addResult</a>.</li>
</ul>
</li>
</ol>
<p>To aid in managing the state of computation, the IRule class has helper functions to allocate a <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a>. The StateContainer is a templatized class that stores a one or two dimensional array of data. The class contains three functions for checking, updating, and fetching the data: get, set, and has. <a class="el" href="classhtgs_1_1_state_container.html#ad910a57b08190e00e9950bf139d79dce" title="Gets a value from a row column. ">htgs::StateContainer::get</a> will retrieve the data stored within the container; <a class="el" href="classhtgs_1_1_state_container.html#a0e43315d18e17eab3e90e1712d0680db" title="Sets a value (by reference) at a row column. ">htgs::StateContainer::set</a> stores data at the specified location within the container, and <a class="el" href="classhtgs_1_1_state_container.html#ab66e44251551ea2367bee974d36af306" title="Checks whether the specified row column has data. ">htgs::StateContainer::has</a> checks whether data exists at a location or not. The MatrixLoadRule uses the StateContainer to check for its dependencies and pass the pointer for that dependency to the HadamardProduct ITask.</p>
<p>### MatrixLoadRule {#load-rule} </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_i_rule_8hpp.html">htgs/api/IRule.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../data/MatrixBlockMulData.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MatrixLoadRule: <span class="keyword">public</span> <a class="code" href="classhtgs_1_1_i_rule.html">htgs::IRule</a>&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;, MatrixBlockMulData&gt; {</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MatrixLoadRule(<span class="keywordtype">int</span> blockWidth, <span class="keywordtype">int</span> blockHeight) {</div><div class="line">    this-&gt;blockWidth = blockWidth;</div><div class="line">    this-&gt;blockHeight = blockHeight;</div><div class="line"></div><div class="line">    this-&gt;arrayAState = this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#a8baa4e2f1a4126d21fe20ca378a5a72b">allocStateContainer</a>(blockWidth, blockHeight);</div><div class="line">    this-&gt;arrayBState = this-&gt;<a class="code" href="classhtgs_1_1_i_rule.html#a8baa4e2f1a4126d21fe20ca378a5a72b">allocStateContainer</a>(blockWidth, blockHeight);</div><div class="line">  }</div><div class="line"></div><div class="line">  ~MatrixLoadRule() {</div><div class="line">    <span class="keyword">delete</span> arrayAState;</div><div class="line">    <span class="keyword">delete</span> arrayBState;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classhtgs_1_1_i_rule.html#acf7da2e1b9b25fce31a4dedb34d0df94">canTerminateRule</a>(<span class="keywordtype">int</span> pipelineId) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_rule.html#ab4ce46ea03c5c21db97eb51ae42dbe1b">shutdownRule</a>(<span class="keywordtype">int</span> pipelineId) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4">applyRule</a>(std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;&gt; data, <span class="keywordtype">int</span> pipelineId) {</div><div class="line">    std::shared_ptr&lt;MatrixRequestData&gt; request = data-&gt;getRequest();</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (request-&gt;getType()) {</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixA:</div><div class="line">        this-&gt;arrayAState-&gt;set(request-&gt;getRow(), request-&gt;getCol(), data);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (this-&gt;arrayBState-&gt;has(request-&gt;getRow(), request-&gt;getCol())) {</div><div class="line">          <a class="code" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a>(<span class="keyword">new</span> MatrixBlockMulData(data, this-&gt;arrayBState-&gt;get(request-&gt;getRow(), request-&gt;getCol())));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixB:</div><div class="line">        this-&gt;arrayBState-&gt;set(request-&gt;getRow(), request-&gt;getCol(), data);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (this-&gt;arrayAState-&gt;has(request-&gt;getRow(), request-&gt;getCol())) {</div><div class="line">          <a class="code" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2">addResult</a>(<span class="keyword">new</span> MatrixBlockMulData(this-&gt;arrayAState-&gt;get(request-&gt;getRow(), request-&gt;getCol()), data));</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> MatrixType::MatrixC:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::string <a class="code" href="classhtgs_1_1_i_rule.html#a148fee616c01f057ddc522f2bf6a8b20">getName</a>() {</div><div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MatrixLoadRule&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> blockWidth;</div><div class="line">  <span class="keywordtype">int</span> blockHeight;</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;</a>&gt;&gt; *arrayAState;</div><div class="line">  <a class="code" href="classhtgs_1_1_state_container.html">htgs::StateContainer&lt;std::shared_ptr&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;</a>&gt;&gt; *arrayBState;</div><div class="line">};</div></div><!-- fragment --><h3><a class="anchor" id="bookkeeper-notes"></a>
Notes</h3>
<ul>
<li>The <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> is an ITask defined by the HTGS API that manages depedencies between one or more consumer ITasks.</li>
<li>A <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> defines the connection between a Bookkeeper and a consumer ITask.<ul>
<li>There can be multiple IRules for each Bookkeeper to consumer connection, these connections are managed by the <a class="el" href="classhtgs_1_1_rule_manager.html" title="Connects a Bookkeeper to another ITask using one or more IRule(s). ">htgs::RuleManager</a></li>
</ul>
</li>
<li>The <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> input type must match the <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a> type, and the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> output type must match the consumer ITask's input type</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a>'s are accessed synchronously</li>
<li>Every <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> implements three functions: canTerminateRule, shutdownRule, and applyRule<ul>
<li>shutdownRule should NOT deallocate memory. Memory deallocation should be done in the IRule's destructor</li>
</ul>
</li>
<li><a class="el" href="classhtgs_1_1_i_rule.html#ab97407718736e3ee65417aecf9e79cc2" title="Adds a result value to the output. ">htgs::IRule::addResult</a> should be used within <a class="el" href="classhtgs_1_1_i_rule.html#af9621be64de28b94f76e3f3e0a2d62b4" title="Pure virtual function to process input data. ">htgs::IRule::applyRule</a> to pass data to the IRule's consumer task</li>
<li>The <a class="el" href="classhtgs_1_1_state_container.html" title="Class to hold one/two dimensional state information. ">htgs::StateContainer</a> can be used to help manage the state of computation for input data or other types of state data</li>
</ul>
<h2><a class="anchor" id="memory-manager"></a>
Throttling Tasks with a Memory Manager</h2>
<p>The <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> is an ITask that is created when connecting two ITasks together as a memory edge. A memory edge is similar to any other edge, except it connects two ITasks directly rather than through a TaskScheduler. When connecting two ITask's, one task is declared the memoryEdges and the other task is the releaseMemoryEdges. The memoryEdges requests data from the output <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a> of the MemoryManager, and the releaseMemoryEdges sends data to the input <a class="el" href="classhtgs_1_1_connector.html" title="Manages the input/output of IData between Tasks. ">htgs::Connector</a> for the MemoryManager. Each memory edge contains a name associated with the edge. This way a single ITask can have multiple memory edges connected to it assuming each edge has a unique name.</p>
<p>Every ITask has the capabilities to get memory data from a memory manager edge. Using the htgs::TaskGraph::addMemoryManagerEdge function, two ITasks will be connected by a MemoryManager. The ITask that is getting memory must be in the graph instance that is used to call the addMemoryManagerEdge function. The parameters for the addMemoryManagerEdge function specifies the name of the edge, the memoryEdges ITask, the releaseMemoryEdges ITask, the IMemoryAllocator, the memory pool size, and the type of memory manager to use. The name that is specified by the addMemoryManagerEdge function must be used by the ITasks that will be releasing/getting memory to/from that MemoryManager.</p>
<p>The memory allocator defines the type of data to be allocated, as well as how the memory is allocated/freed. The type parameter defined in the allocator is used as the type template when getting memory for an ITask. The memory pool size is used to throttle the ITask that is getting memory. If the pool is empty, then the ITask's threads will wait until memory has been released to the memory pool for the MemoryManager.</p>
<p>When an ITask gets memory, it specifies the type of memory, the name of the memory manger edge, and that memory's <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>. The IMemoryReleaseRule is a programmer-defined interface that describes how/when that memory data can be released. If there is a possibility that the memory edge was not added, then the ITask can check if the memory edge exists using the ITask::hasMemGetter or ITask::hasMemReleaser functions. If an ITask attempts to get or release memory from an edge that does not exist, then the program will fail an assertion or segmentation fault.</p>
<p>There are three types of MemoryManagers: Static, Dynamic, and UserManaged. Each MemoryManager type modifies how/when memory is allocated and freed.</p>
<p>All MemoryManager types allocates a pool of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> during the ITask::initialize phase. However, the Static MemoryManager will also allocate the internal memory that the MemoryData is holding. The Static MemoryManager will release this memory once the MemoryManager is shutdown.</p>
<p>In the next sections, we will go into the details as to how each of these MemoryManager types vary and process MemoryData.</p>
<h3><a class="anchor" id="static-mm"></a>
Static Memory Manager</h3>
<p>The static MemoryManager is a memory manager that recycles memory when it is released. All of the memory for the memory pool is allocated once when the MemoryManager is initialized and freed when the MemoryManager is shutdown. The diagram below shows how MemoryData is processed when an ITask releases memory. First, when MemoryData enters the MemoryManager, the MemoryData's state is updated using the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ad4d88cfa3383b6cc0e9e629e84d92e67" title="Pure virtual function to update the state of when memory has been used. ">htgs::IMemoryReleaseRule::memoryUsed</a> function.</p>
<p>Next, the MemoryManager checks the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ae6135cc2b517ea2bcf99617b312758dd" title="Pure virtual function to indicate when memory can be released. ">htgs::IMemoryReleaseRule::canReleaseMemory</a> function to determine whether the state indicates the memory can be freed or not. If the state indicates it can be freed, then the MemoryData is inserted into the MemoryPool. If it is not freed, then the MemoryData will not be recycled. Next, the MemoryPool is emptied into the MemoryManager's output Connector so the ITask getting memory can wake up and acquire MemoryData.</p>
<div class="image">
<img src="figures/staticMemoryManager.png"  style="width: 100%;"/>
</div>
<h3><a class="anchor" id="dynamic-mm"></a>
Dynamic Memory Manager</h3>
<p>The dynamic MemoryManager contains a similar structure as the static MemoryManager with how it processes MemoryData. The primary difference is when the dynamic MemoryManager allocates and frees memory. In the static MemoryManager all memory is allocated during initialization and freed during shutdown. The dynamic MemoryManager allocates and frees memory on-the-fly. As shown in the diagram below, when MemoryData is sent from the releaseMemoryEdges, if the memory can be released, then the MemoryManager will free the memory that the MemoryData is managing. When the memoryEdges acquires memory from the MemoryManager, the ITask will allocate the memory that the MemoryData is managing prior to returning the MemoryData to the ITask. Using these mechanisms the memory is allocated and freed on demand.</p>
<div class="image">
<img src="figures/dynamicMemoryManager.png"  style="width: 100%;"/>
</div>
<h3><a class="anchor" id="user-managed-mm"></a>
User Managed Memory Manager</h3>
<p>The user managed MemoryManager assumes the programmer is taking the necessary precautions with memory allocation, state, and freeing of memory. The MemoryManager in this case acts purely as a throttling mechanism to aid in keeping track of how many memory allocations are in flight within a TaskGraph. The ITask that is allocating memory calls htgs::ITask::allocUserManagedMemory to get permission to allocate memory. If there is no memory within the MemoryPool of the user managed MemoryManager, then this function will block until the releaseMemoryEdges releases memory. There are no IMemoryReleaseRules associated with MemoryManagers, and any memory release metadata must be managed by the programmer.</p>
<div class="image">
<img src="figures/userMemoryManager.png"  style="width: 90%;"/>
</div>
<p>Within the <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> there are two functions that must be defined to use a MemoryManager edge: (1) <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a>, and (2) <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>. The IMemoryAllocator is specified when creating the memory edge, while the IMemoryReleaseRule is added to MemoryData when the memoryEdges gets memory. For the HadamardProduct task, we define the MatrixAllocator and MatrixMemoryRule as the <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a> and <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>, respectively. Below is the code that defines these classes.</p>
<p>The MatrixAllocator creates a one-dimensional array with the specified size using the new operator and releases the memory using the delete[] operator.</p>
<p>The MatrixMemoryRule uses a release count to determine when the memory is ready to be released. When the memoryGetter requests memory, a new instance of the MatrixMemoryRule is defined and bound to the MemoryData that is fetched. This IMemoryReleaseRule is then used by the MemoryManager by calling the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ad4d88cfa3383b6cc0e9e629e84d92e67" title="Pure virtual function to update the state of when memory has been used. ">htgs::IMemoryReleaseRule::memoryUsed()</a> function, which decrements the release count. The MemoryManager then checks if the memory can be released with the <a class="el" href="classhtgs_1_1_i_memory_release_rule.html#ae6135cc2b517ea2bcf99617b312758dd" title="Pure virtual function to indicate when memory can be released. ">htgs::IMemoryReleaseRule::canReleaseMemory()</a>, which returns true if the release count is zero.</p>
<p>Each matrix block in the HadamardProduct is only used once, so after the specified row, column has been computed, then the memory associated with that computation can be released. This aspect is represented by defining the release count for the MatrixMemoryRule to be one.</p>
<p>### MatrixAllocator {#matrix-allocator} </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;htgs/api/IMemoryAllocator.hpp&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;class MatrixAllocator : public htgs::IMemoryAllocator&lt;double *&gt; {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; public:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  MatrixAllocator(int width, int height) : IMemoryAllocator((size_t) width * height) { }</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  double *memAlloc(size_t size) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    double *mem = new double[size];</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    return mem;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  double *memAlloc() {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    double *mem = new double[this-&gt;size()];</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    return mem;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  }</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  void memFree(double *&amp;memory) {</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    delete[] memory;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  }</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;};</div></div><!-- fragment --><p>### MatrixMemoryRule {#matrix-memory-rule} </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;htgs/api/IMemoryReleaseRule.hpp&gt;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;class MatrixMemoryRule: public htgs::IMemoryReleaseRule {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; public:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  MatrixMemoryRule(int releaseCount) : releaseCount(releaseCount) {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  }</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  void memoryUsed() {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    releaseCount--;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  bool canReleaseMemory() {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    return releaseCount == 0;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  }</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; private:</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  int releaseCount;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;};</div></div><!-- fragment --><h3><a class="anchor" id="memorymanagement-notes"></a>
Notes</h3>
<ul>
<li>MemoryManager manages the memory that is used/recycled within a TaskGraph as well as to help throttle a TaskGraph to ensure the TaskGraph does not allocate too much memory.</li>
<li>There are three types of memory managers: Static, Dynamic, and UserManaged<ul>
<li>Type is defined when adding the memory edge to the htgs::TaskGraph</li>
<li>Primary difference is how/when memory is allocated/freed</li>
</ul>
</li>
<li>When connecting a memory getter with a memory releaser, the memory getter must already be added to the TaskGraph prior to declaring the memory getter for the given TaskGraph.<ul>
<li>The memory releaser does not have to be within the same TaskGraph</li>
<li>The memory releaser can be bound to a TaskGraph to be accessed by the main thread (or another separate thread that has an instance of the TaskGraph)</li>
</ul>
</li>
<li>The <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a> defines what type of memory is allocated, how the memory is allocated, and how the memory is freed<ul>
<li>Use the type defined for the IMemoryAllocator&lt;Type&gt; when getting memory from within an ITask using htgs::ITask::memGet&lt;Type&gt;()</li>
</ul>
</li>
<li>The <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> is used to define the state of <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> to help determine when the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">htgs::MemoryManager</a> can recycle/free memory<ul>
<li>The IMemoryReleaseRule is added to <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> when an ITask gets memory.</li>
<li>Each <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a> should have a separate instances of <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> objects (a new instance per MemoryData)</li>
</ul>
</li>
<li>The <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> should follow the data flow behavior of the TaskGraph to ensure that the memory gets released.<ul>
<li>If memory does not get released and the memory getter is waiting for memory, then deadlock can occur.</li>
<li>There should be enough elements in the memory pool to progress the TaskGraph so that the IMemoryReleaseRule can allow data to be released.</li>
</ul>
</li>
<li>The memory edge that connects two ITasks is a separate edge from the main TaskGraph connections.<ul>
<li>The main connections use TaskSchedulers, the memory edge directly connects two ITasks together.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="create-and-execute-taskgraph"></a>
Creating and Executing the TaskGraph</h2>
<p>As shown in Tutorial1, we use the TaskGraph to connect all our components that can then be executed using threads. The new TaskGraph functions we will be using to connect these components are: htgs::TaskGraph::addRule(), htgs::TaskGraph::addMemoryManagerEdge(), and htgs::TaskGraph::addGraphUserManagedMemoryManagerEdge().</p>
<p>Below is the main function for computing the HadamardProduct using HTGS. The matrix dimensions are 1024x1024 and a block size of</p><ol type="1">
<li>Modifying the block size or matrix dimensions will require recreating the matrix data with the test/matrix-ops/generateMatrix.cpp test case.</li>
</ol>
<p>To add a dependency IRule to a graph, use the htgs::TaskGraph::addRule function. This requires the creation of a <a class="el" href="classhtgs_1_1_bookkeeper.html" title="Special task used to manage rules. ">htgs::Bookkeeper</a>, the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a> consumer task, and the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> that produces data for the consumer.</p>
<p>There are a number of ways for adding memory edges to a TaskGraph. Prior to adding any memory edges, the ITask that is acting as the memoryEdges must be added to the graph prior to adding the memory edge to that graph.</p>
<p>The functions for adding a memory edge to a graph are defined below:</p>
<p>1) htgs::TaskGraph::addUserManagedMemoryManagerEdge(std::string name, BaseITask *memoryEdges, BaseITask *releaseMemoryEdges, int memoryPoolSize)</p><ul>
<li>Creates a memory edge that is managed by the programmer/user. The MemoryManager acts to simply manage how much memory has been allocated. Does not use any allocators. Within an ITask use htgs::ITask::allocUserManagedMemory to get permission to allocate memory and htgs::ITask::memRelease(name, pipelineId).</li>
</ul>
<p>2) htgs::TaskGraph::addMemoryManagerEdge(std::string name, BaseITask *memoryEdges, BaseITask *releaseMemoryEdges, IMemoryAllocator&lt;V&gt; *allocator, int memoryPoolSize, htgs::MMType type)</p><ul>
<li>Creates a memory edge that is managed based on <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a>'s attached to <a class="el" href="classhtgs_1_1_memory_data.html" title="Describes memory allocated by a MemoryManager to manage shared memory across multiple ITask...">htgs::MemoryData</a>. The htgs::IMemoryAllocator&lt;V&gt; defines how memory is allocated and freed and determines the type of the memory being allocated. The memory pool size determines the number of elements in the memory pool. If the MemoryManager is static, then all of the memory will be allocated during initialization.</li>
</ul>
<p>3) htgs::TaskGraph::addGraphUserManagedMemoryManagerEdge(std::string name, BaseITask *memoryEdges, int memoryPoolSize)</p><ul>
<li>Similar to htgs::TaskGraph::addUserManagedMemoryManagerEdge, except the memory releaser exists outside of the task graph. This methodology is demonstrated in the HadamardProduct main function when processing data produced by the TaskGraph.</li>
</ul>
<p>4) htgs::TaskGraph::addGraphMemoryManagerEdge(std::string name, BaseITask *memoryEdges, IMemoryAllocator&lt;V&gt; *allocator, int memoryPoolSize, htgs::MMType type)</p><ul>
<li>Similar to htgs::addMemoryManagerEdge, except the memory releaser exists outside of the task graph.</li>
</ul>
<p>5) htgs::TaskGraph::addMemoryManagerEdge(BaseITask *memoryEdges, BaseITask *releaseMemoryEdges, MemoryManager&lt;V&gt; *memoryManager, bool ignoreMemGetterErrors)</p><ul>
<li>Creates a memory manager edge with the provided MemoryManager. This allows for additional special types of memory managers, such as MemoryManager's allocating memory for other devices such as with OpenCL.</li>
</ul>
<p>As shown there are functions for designating the memory releaser to be attached to the TaskGraph. This means that any user with an instance of a TaskGraph can release memory for a memoryEdges Task within the TaskGraph. Here are the functions that can be used to interact with the memory releaser attached to the TaskGraph when using the htgs::TaskGraph::addGraphUserManagedMemoryManagerEdge and htgs::TaskGraph::addGraphMemoryManagerEdge.</p>
<p>1) htgs::TaskGraph::hasMemReleaser(std::string name)</p><ul>
<li>Checks if the TaskGraph is a memory releaser for the named memory edge.</li>
</ul>
<p>2) htgs::TaskGraph::memRelease(std::string name, std::shared_ptr&lt;MemoryData&lt;V&gt;&gt; memory)</p><ul>
<li>Releases memory for the named memory edge. (Static and Dynamic MMType)</li>
</ul>
<p>3) htgs::TaskGraph::memRelease(std::string name, int pipelineId)</p><ul>
<li>Releases memory for the named memory edge. (UserManaged MMType)</li>
</ul>
<p>Belows is the source code implementation for setup, construction of the task TaskGraph, executing the TaskGraph, and processing the output of the TaskGraph.</p>
<h3><a class="anchor" id="main-function"></a>
Main function (Hadamard Product)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;htgs/api/TaskGraph.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;htgs/api/Runtime.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;data/MatrixRequestData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;data/MatrixBlockData.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/ReadMatrixTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;memory/MatrixAllocator.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;rules/MatrixLoadRule.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;tasks/HadamardProductTask.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../api/SimpleClock.h&quot;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> width = 1024;</div><div class="line">  <span class="keywordtype">int</span> height = 1024;</div><div class="line">  <span class="keywordtype">int</span> blockSize = 256;</div><div class="line">  <span class="keywordtype">int</span> numReadThreads = 1;</div><div class="line">  <span class="keywordtype">int</span> numProdThreads = 10;</div><div class="line"></div><div class="line">  std::string directory(<span class="stringliteral">&quot;data/tutorial2/1024x1024blksize256&quot;</span>);</div><div class="line"></div><div class="line">  ReadMatrixTask *readMatTask = <span class="keyword">new</span> ReadMatrixTask(numReadThreads, blockSize, width, height, directory);</div><div class="line">  MatrixMulBlkTask *prodTask = <span class="keyword">new</span> MatrixMulBlkTask(numProdThreads);</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> numBlocksCols = readMatTask-&gt;getNumBlocksCols();</div><div class="line">  <span class="keywordtype">int</span> numBlocksRows = readMatTask-&gt;getNumBlocksRows();</div><div class="line"></div><div class="line">  MatrixLoadRule *loadRule = <span class="keyword">new</span> MatrixLoadRule(numBlocksCols, numBlocksRows);</div><div class="line">  <span class="keyword">auto</span> bookkeeper = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&lt;MatrixMemoryData_t&gt;</a>&gt;();</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> taskGraph = <span class="keyword">new</span> htgs::TaskGraph&lt;MatrixRequestData, MatrixBlockData&lt;double *&gt;&gt;();</div><div class="line"></div><div class="line">  taskGraph-&gt;addGraphInputConsumer(readMatTask);</div><div class="line">  taskGraph-&gt;addEdge(readMatTask, bookkeeper);</div><div class="line">  taskGraph-&gt;addRule(bookkeeper, prodTask, loadRule);</div><div class="line">  taskGraph-&gt;addGraphOutputProducer(prodTask);</div><div class="line"></div><div class="line">  taskGraph-&gt;addGraphUserManagedMemoryManagerEdge(<span class="stringliteral">&quot;outputMem&quot;</span>, prodTask, 50);</div><div class="line"></div><div class="line">  taskGraph-&gt;addMemoryManagerEdge(<span class="stringliteral">&quot;matrixA&quot;</span>, readMatTask, prodTask, <span class="keyword">new</span> MatrixAllocator(blockSize, blockSize), 100, htgs::MMType::Static);</div><div class="line">  taskGraph-&gt;addMemoryManagerEdge(<span class="stringliteral">&quot;matrixB&quot;</span>, readMatTask, prodTask, <span class="keyword">new</span> MatrixAllocator(blockSize, blockSize), 100, htgs::MMType::Static);</div><div class="line"></div><div class="line">  taskGraph-&gt;incrementGraphInputProducer();</div><div class="line"></div><div class="line">  htgs::Runtime *runtime = <span class="keyword">new</span> htgs::Runtime(taskGraph);</div><div class="line"></div><div class="line">  SimpleClock clk;</div><div class="line">  clk.start();</div><div class="line"></div><div class="line">  runtime-&gt;executeRuntime();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> row = 0; row &lt; numBlocksRows; row++)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col = 0; col &lt; numBlocksCols; col++)</div><div class="line">    {</div><div class="line">      MatrixRequestData * matrixA = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixA);</div><div class="line">      MatrixRequestData * matrixB = <span class="keyword">new</span> MatrixRequestData(row, col, MatrixType::MatrixB);</div><div class="line"></div><div class="line">      taskGraph-&gt;produceData(matrixA);</div><div class="line">      taskGraph-&gt;produceData(matrixB);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  taskGraph-&gt;finishedProducingData();</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (!taskGraph-&gt;isOutputTerminated())</div><div class="line">  {</div><div class="line">    <span class="keyword">auto</span> data = taskGraph-&gt;consumeData();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (data != <span class="keyword">nullptr</span>) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Result received: &quot;</span> &lt;&lt; data-&gt;getRequest()-&gt;getRow() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; data-&gt;getRequest()-&gt;getCol() &lt;&lt;std::endl;</div><div class="line">      <span class="keywordtype">double</span> *mem = data-&gt;getMatrixData();</div><div class="line">      <span class="keyword">delete</span> [] mem;</div><div class="line"></div><div class="line">      taskGraph-&gt;memRelease(<span class="stringliteral">&quot;outputMem&quot;</span>, 0);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  taskGraph-&gt;finishReleasingMemory();</div><div class="line"></div><div class="line">  runtime-&gt;waitForRuntime();</div><div class="line"></div><div class="line">  clk.stopAndIncrement();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Finished running in &quot;</span> &lt;&lt; clk.getAverageTime(TimeVal::MILLI) &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> runtime;</div><div class="line">}</div></div><!-- fragment --><p>Sample execution: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./tutorial2</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Result received: 1, 0</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Result received: 0, 2</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Result received: 1, 3</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Result received: 0, 3</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Result received: 2, 0</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Result received: 0, 0</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Result received: 0, 1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;Result received: 1, 2</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Result received: 1, 1</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;Result received: 2, 1</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Result received: 2, 2</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;Result received: 3, 1</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;Result received: 3, 0</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Result received: 2, 3</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;Result received: 3, 2</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;Result received: 3, 3</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;Finished running in 5.67444 ms</div></div><!-- fragment --><h3><a class="anchor" id="taskgraph-notes"></a>
Notes</h3>
<ul>
<li>The htgs::TaskGraph::addRule is used to add an <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a> to a TaskGraph<ul>
<li>Manages dependencies</li>
<li>Determines when data is sent to a consumer ITask.</li>
</ul>
</li>
<li>Multiple functions for adding the memory edge to a TaskGraph<ul>
<li>Allows for custom MemoryManager tasks</li>
<li>Support for TaskGraph memory releasers</li>
</ul>
</li>
<li>For memory edges, the memory pool size parameter is import to specify based on amount of memory available and the dataflow behavior in relation to the memory usage behavior<ul>
<li>If not enough memory is available to allow for memory to be released, then the TaskGraph will deadlock</li>
<li>The more memory available, the more data elements that can flow through the TaskGraph to improve pipelining.</li>
</ul>
</li>
<li>Similar to the ITask API to operate with memory edges, the TaskGraph has a similar API to manage the memory edges attached to the TaskGraph.</li>
</ul>
<h1><a class="anchor" id="summary"></a>
Summary </h1>
<p>In this tutorial, we looked at parallelism/pipelining, handling dependencies and memory management.</p><ul>
<li>A method for representing an algorithm to maximize pipelining and parallelism</li>
<li>More advanced methods for representing <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">htgs::IData</a></li>
<li>How to specify a pool of threads for an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">htgs::ITask</a></li>
<li>The functions needed to define a dependency using <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">htgs::IRule</a></li>
<li>The various types of memory managers</li>
<li>How to use the memory management system with <a class="el" href="classhtgs_1_1_i_memory_release_rule.html" title="Abstract class that describes when memory can be released/reused. ">htgs::IMemoryReleaseRule</a> and <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">htgs::IMemoryAllocator</a></li>
<li>The importance of understanding memory usage behavior in relationship to memory edges to prevent TaskGraph deadlocks.</li>
</ul>
<p>In the next tutorial, we will be implementing an in-core matrix multiplication using block decomposition and the openblas API. The tutorial will introduce how to use computational functions from other APIs (openblas), using a Bookkeeper that branches execution, and how to define multiple memory release edges for the same memory manager. There will be a couple iterations of tutorial3 to demonstrate alternative methods for allocating memory, such as using memory mapped files versus the file structure shown in this tutorial. In tutorial 4, we will take this computation and set it up as an out-of-core algorithm.</p>
<p>Additional information:</p><ul>
<li>Generating the a dot file using htgs::TaskGraph::writeDotToFile after executing a TaskGraph will create a dot file that visualizes all of the threading that takes place within the htgs::Runtime. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
