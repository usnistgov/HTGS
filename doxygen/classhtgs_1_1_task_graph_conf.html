<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>HTGS: htgs::TaskGraphConf&lt; T, U &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="image-styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="HTGS-Logo-color-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HTGS
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The Hybrid Task Graph Scheduler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhtgs_1_1_task_graph_conf.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classhtgs_1_1_task_graph_conf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">htgs::TaskGraphConf&lt; T, U &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages a group of connected ITasks and their connections.  
 <a href="classhtgs_1_1_task_graph_conf.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_task_graph_conf_8hpp_source.html">htgs/api/TaskGraphConf.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for htgs::TaskGraphConf&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_task_graph_conf__inherit__graph.png" border="0" usemap="#htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_inherit__map" id="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_inherit__map">
<area shape="rect" id="node2" href="classhtgs_1_1_any_task_graph_conf.html" title="Implements the base class for the TaskGraphConf class, removing the template arguments and providing ..." alt="" coords="5,5,240,361"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for htgs::TaskGraphConf&lt; T, U &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classhtgs_1_1_task_graph_conf__coll__graph.png" border="0" usemap="#htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_coll__map" id="htgs_1_1_task_graph_conf_3_01_t_00_01_u_01_4_coll__map">
<area shape="rect" id="node2" href="classhtgs_1_1_any_task_graph_conf.html" title="Implements the base class for the TaskGraphConf class, removing the template arguments and providing ..." alt="" coords="371,1565,605,1833"/>
<area shape="rect" id="node4" href="classhtgs_1_1_any_task_manager.html" title="The parent class for a Task that removes the template arguments. " alt="" coords="673,977,831,1333"/>
<area shape="rect" id="node5" href="classhtgs_1_1_task_graph_communicator.html" title="Implements the task graph communicator where a task&#39;s address and name are mapped to their input conn..." alt="" coords="709,632,939,915"/>
<area shape="rect" id="node6" href="classhtgs_1_1_blocking_queue.html" title="{htgs::BlockingQueue\l\&lt; std::shared_ptr\&lt; htgs\l::DataPacket \&gt; \&gt;\n|&#45; queueSize\l&#45; mutex\l&#45; condition\l|+ BlockingQueue()\l+ BlockingQueue()\l+ ~BlockingQueue()\l+ remainingCapacity()\l+ isEmpty()\l+ size()\l+ remove()\l+ Enqueue()\l+ Dequeue()\l+ poll()\l}" alt="" coords="1074,301,1233,569"/>
<area shape="rect" id="node8" title="STL class. " alt="" coords="580,154,660,231"/>
<area shape="rect" id="node9" title="STL class. " alt="" coords="557,5,683,97"/>
<area shape="rect" id="node11" title="STL class. " alt="" coords="966,397,1050,474"/>
<area shape="rect" id="node12" title="STL class. " alt="" coords="342,389,479,481"/>
<area shape="rect" id="node15" title="STL class. " alt="" coords="195,397,317,474"/>
<area shape="rect" id="node16" title="STL class. " alt="" coords="5,389,171,481"/>
<area shape="rect" id="node18" href="classhtgs_1_1_edge_descriptor.html" title="The edge descriptor is an interface used to describe how an edge is applied and copied to a task grap..." alt="" coords="1214,1396,1359,1503"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5be2d8e8919ab1e7b23da33cb74c8ad5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5be2d8e8919ab1e7b23da33cb74c8ad5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a5be2d8e8919ab1e7b23da33cb74c8ad5">TaskGraphConf</a> ()</td></tr>
<tr class="memdesc:a5be2d8e8919ab1e7b23da33cb74c8ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a TaskGraph. <br /></td></tr>
<tr class="separator:a5be2d8e8919ab1e7b23da33cb74c8ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67aeba76921f17058e0972b89146d16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#ad67aeba76921f17058e0972b89146d16">TaskGraphConf</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>, std::string baseAddress, <a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *parentCommunicator)</td></tr>
<tr class="memdesc:ad67aeba76921f17058e0972b89146d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a TaskGraph.  <a href="#ad67aeba76921f17058e0972b89146d16">More...</a><br /></td></tr>
<tr class="separator:ad67aeba76921f17058e0972b89146d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323f679f264c726a61ea7ae50f02914a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a323f679f264c726a61ea7ae50f02914a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a323f679f264c726a61ea7ae50f02914a">~TaskGraphConf</a> () override</td></tr>
<tr class="memdesc:a323f679f264c726a61ea7ae50f02914a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, handles releasing all <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> memory that is managed by the TaskGraph. <br /></td></tr>
<tr class="separator:a323f679f264c726a61ea7ae50f02914a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6885d5ddfcee1dadee68e5b9a586a0f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html">AnyTaskGraphConf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a6885d5ddfcee1dadee68e5b9a586a0f1">copy</a> () override</td></tr>
<tr class="memdesc:a6885d5ddfcee1dadee68e5b9a586a0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an exact copy of this task graph.  <a href="#a6885d5ddfcee1dadee68e5b9a586a0f1">More...</a><br /></td></tr>
<tr class="separator:a6885d5ddfcee1dadee68e5b9a586a0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163409dd38587f67b49502835ca107fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a163409dd38587f67b49502835ca107fe">copy</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>)</td></tr>
<tr class="memdesc:a163409dd38587f67b49502835ca107fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines.  <a href="#a163409dd38587f67b49502835ca107fe">More...</a><br /></td></tr>
<tr class="separator:a163409dd38587f67b49502835ca107fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a135c436eb931cc7d002758e021335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt; T, U &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a32a135c436eb931cc7d002758e021335">copy</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html#a9c072839d748de933ae96371313dd52d">input</a>, std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html#a93f6a48dc9c378889e2b48ca70e27776">output</a>, std::string baseAddress, <a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *parentCommunicator)</td></tr>
<tr class="memdesc:a32a135c436eb931cc7d002758e021335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines, and updates the input and output connectors for the graph copy.  <a href="#a32a135c436eb931cc7d002758e021335">More...</a><br /></td></tr>
<tr class="separator:a32a135c436eb931cc7d002758e021335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf80f060f13a40b41579a8678acad01"><td class="memTemplParams" colspan="2">template&lt;class V , class W , class X &gt; </td></tr>
<tr class="memitem:aeaf80f060f13a40b41579a8678acad01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01">addEdge</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; V, W &gt; *producer, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="memdesc:aeaf80f060f13a40b41579a8678acad01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph, where one task produces data for a consumer task.  <a href="#aeaf80f060f13a40b41579a8678acad01">More...</a><br /></td></tr>
<tr class="separator:aeaf80f060f13a40b41579a8678acad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfc932815a7b264da00c35d274f5274"><td class="memTemplParams" colspan="2">template&lt;class V , class IRuleType , class W , class X &gt; </td></tr>
<tr class="memitem:aedfc932815a7b264da00c35d274f5274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274">addRuleEdge</a> (<a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *bookkeeper, std::shared_ptr&lt; IRuleType &gt; rule, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="memdesc:aedfc932815a7b264da00c35d274f5274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rule edge that is managed by a bookkeeper.  <a href="#aedfc932815a7b264da00c35d274f5274">More...</a><br /></td></tr>
<tr class="separator:aedfc932815a7b264da00c35d274f5274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="memTemplParams" colspan="2">template&lt;class V , class W , class X &gt; </td></tr>
<tr class="memitem:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#ac3d41cc1d73dfda04f8f9ab48a525980">addRuleEdge</a> (<a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *bookkeeper, <a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; *iRule, <a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *consumer)</td></tr>
<tr class="memdesc:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rule edge that is managed by a bookkeeper.  <a href="#ac3d41cc1d73dfda04f8f9ab48a525980">More...</a><br /></td></tr>
<tr class="separator:ac3d41cc1d73dfda04f8f9ab48a525980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d42580bc4a385943ae53d22108fdef8"><td class="memTemplParams" colspan="2">template&lt;class V , class IMemoryAllocatorType &gt; </td></tr>
<tr class="memitem:a0d42580bc4a385943ae53d22108fdef8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a0d42580bc4a385943ae53d22108fdef8">addCudaMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type, CUcontext *contexts)</td></tr>
<tr class="memdesc:a0d42580bc4a385943ae53d22108fdef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a0d42580bc4a385943ae53d22108fdef8">More...</a><br /></td></tr>
<tr class="separator:a0d42580bc4a385943ae53d22108fdef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806d4e5a57572f548c6682c81b28084e"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a806d4e5a57572f548c6682c81b28084e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a806d4e5a57572f548c6682c81b28084e">addCudaMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type, CUcontext *contexts)</td></tr>
<tr class="memdesc:a806d4e5a57572f548c6682c81b28084e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a806d4e5a57572f548c6682c81b28084e">More...</a><br /></td></tr>
<tr class="separator:a806d4e5a57572f548c6682c81b28084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a3e01d687d11fcd4a7c9bd90f8f65a7f3">addCustomMemoryManagerEdge</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_memory_manager.html">MemoryManager</a>&lt; V &gt; *memoryManager)</td></tr>
<tr class="memdesc:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a3e01d687d11fcd4a7c9bd90f8f65a7f3">More...</a><br /></td></tr>
<tr class="separator:a3e01d687d11fcd4a7c9bd90f8f65a7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88adcd11f63ba49703f82f1210d0f0eb"><td class="memTemplParams" colspan="2">template&lt;class V , class IMemoryAllocatorType &gt; </td></tr>
<tr class="memitem:a88adcd11f63ba49703f82f1210d0f0eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb">addMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, std::shared_ptr&lt; IMemoryAllocatorType &gt; allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type)</td></tr>
<tr class="memdesc:a88adcd11f63ba49703f82f1210d0f0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a88adcd11f63ba49703f82f1210d0f0eb">More...</a><br /></td></tr>
<tr class="separator:a88adcd11f63ba49703f82f1210d0f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442420d2c9c115ca9f9c644f7e5c985f"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a442420d2c9c115ca9f9c644f7e5c985f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a442420d2c9c115ca9f9c644f7e5c985f">addMemoryManagerEdge</a> (std::string name, <a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *getMemoryTask, <a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *allocator, size_t memoryPoolSize, <a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a> type)</td></tr>
<tr class="memdesc:a442420d2c9c115ca9f9c644f7e5c985f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a442420d2c9c115ca9f9c644f7e5c985f">More...</a><br /></td></tr>
<tr class="separator:a442420d2c9c115ca9f9c644f7e5c985f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e19bcf91fb99751ba47f32bc755ba0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a0e19bcf91fb99751ba47f32bc755ba0a">getGraphConsumerTaskManager</a> () override</td></tr>
<tr class="memdesc:a0e19bcf91fb99751ba47f32bc755ba0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function that gets the task manager that is consuming data from the graph's input.  <a href="#a0e19bcf91fb99751ba47f32bc755ba0a">More...</a><br /></td></tr>
<tr class="separator:a0e19bcf91fb99751ba47f32bc755ba0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c30736911d28514e76cb44fe92351f0"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c30736911d28514e76cb44fe92351f0">getGraphProducerTaskManagers</a> () override</td></tr>
<tr class="memdesc:a2c30736911d28514e76cb44fe92351f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the list of task managers that are producing data for the graph's output.  <a href="#a2c30736911d28514e76cb44fe92351f0">More...</a><br /></td></tr>
<tr class="separator:a2c30736911d28514e76cb44fe92351f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefecdde12a738f08e41f410015afb6e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#abefecdde12a738f08e41f410015afb6e">getInputConnector</a> () override</td></tr>
<tr class="memdesc:abefecdde12a738f08e41f410015afb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that gets the connector used for graph input.  <a href="#abefecdde12a738f08e41f410015afb6e">More...</a><br /></td></tr>
<tr class="separator:abefecdde12a738f08e41f410015afb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3a06907ead06a968ab1530922a0ea2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a2d3a06907ead06a968ab1530922a0ea2">getOutputConnector</a> () override</td></tr>
<tr class="memdesc:a2d3a06907ead06a968ab1530922a0ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that gets the connector used for graph output.  <a href="#a2d3a06907ead06a968ab1530922a0ea2">More...</a><br /></td></tr>
<tr class="separator:a2d3a06907ead06a968ab1530922a0ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680be3c29e61ed66fd47ff0a94567c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a680be3c29e61ed66fd47ff0a94567c9d">getTaskGraphCommunicator</a> () const </td></tr>
<tr class="memdesc:a680be3c29e61ed66fd47ff0a94567c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that gets the task graph communicator.  <a href="#a680be3c29e61ed66fd47ff0a94567c9d">More...</a><br /></td></tr>
<tr class="separator:a680be3c29e61ed66fd47ff0a94567c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa359ab69ff6f839d233f2486e32d0605"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa359ab69ff6f839d233f2486e32d0605"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#aa359ab69ff6f839d233f2486e32d0605">updateCommunicator</a> () override</td></tr>
<tr class="memdesc:aa359ab69ff6f839d233f2486e32d0605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function that initiates updating the task graph communicator. <br /></td></tr>
<tr class="separator:aa359ab69ff6f839d233f2486e32d0605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431a592aa2e39914fefef99e99cc2e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a431a592aa2e39914fefef99e99cc2e54">setInputConnector</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html#a9c072839d748de933ae96371313dd52d">input</a>)</td></tr>
<tr class="memdesc:a431a592aa2e39914fefef99e99cc2e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input connector for the task graph.  <a href="#a431a592aa2e39914fefef99e99cc2e54">More...</a><br /></td></tr>
<tr class="separator:a431a592aa2e39914fefef99e99cc2e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac7e33e842cbcc582ddb0a869975588"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a5ac7e33e842cbcc582ddb0a869975588">setOutputConnector</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html#a93f6a48dc9c378889e2b48ca70e27776">output</a>)</td></tr>
<tr class="memdesc:a5ac7e33e842cbcc582ddb0a869975588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output connector for the task graph.  <a href="#a5ac7e33e842cbcc582ddb0a869975588">More...</a><br /></td></tr>
<tr class="separator:a5ac7e33e842cbcc582ddb0a869975588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9a2ea9704c804e089c1794e1e8e664"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a5d9a2ea9704c804e089c1794e1e8e664">incrementGraphProducer</a> ()</td></tr>
<tr class="memdesc:a5d9a2ea9704c804e089c1794e1e8e664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the number of producers for the task graph.  <a href="#a5d9a2ea9704c804e089c1794e1e8e664">More...</a><br /></td></tr>
<tr class="separator:a5d9a2ea9704c804e089c1794e1e8e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1e54bfce0472b38d422f973d3ba68d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d">finishedProducingData</a> ()</td></tr>
<tr class="memdesc:a2c1e54bfce0472b38d422f973d3ba68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the input connector and wakes up any consumer of the graph's input if the input connector is finished producing data.  <a href="#a2c1e54bfce0472b38d422f973d3ba68d">More...</a><br /></td></tr>
<tr class="separator:a2c1e54bfce0472b38d422f973d3ba68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23520b3b3054e16c59784b0d3a289811"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:a23520b3b3054e16c59784b0d3a289811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811">setGraphConsumerTask</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, W &gt; *task)</td></tr>
<tr class="memdesc:a23520b3b3054e16c59784b0d3a289811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the task that is consuming data from the input of the graph.  <a href="#a23520b3b3054e16c59784b0d3a289811">More...</a><br /></td></tr>
<tr class="separator:a23520b3b3054e16c59784b0d3a289811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0857e5a678b01922a513cd2327114864"><td class="memTemplParams" colspan="2">template&lt;class W &gt; </td></tr>
<tr class="memitem:a0857e5a678b01922a513cd2327114864"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a0857e5a678b01922a513cd2327114864">addGraphProducerTask</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, U &gt; *task)</td></tr>
<tr class="memdesc:a0857e5a678b01922a513cd2327114864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the task that is producing data for the output of the graph.  <a href="#a0857e5a678b01922a513cd2327114864">More...</a><br /></td></tr>
<tr class="separator:a0857e5a678b01922a513cd2327114864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834c5f5f07d3cceac5d7f6f9e128e7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef">produceData</a> (T *data)</td></tr>
<tr class="memdesc:a834c5f5f07d3cceac5d7f6f9e128e7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces data for the input of the TaskGraph.  <a href="#a834c5f5f07d3cceac5d7f6f9e128e7ef">More...</a><br /></td></tr>
<tr class="separator:a834c5f5f07d3cceac5d7f6f9e128e7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614839d80ed96f8938d38606e895225a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a614839d80ed96f8938d38606e895225a">produceData</a> (std::shared_ptr&lt; T &gt; data)</td></tr>
<tr class="memdesc:a614839d80ed96f8938d38606e895225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces data for the input of the TaskGraph.  <a href="#a614839d80ed96f8938d38606e895225a">More...</a><br /></td></tr>
<tr class="separator:a614839d80ed96f8938d38606e895225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054eb3b880cd8935d9bfad3a42e1c274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a054eb3b880cd8935d9bfad3a42e1c274">produceData</a> (std::list&lt; std::shared_ptr&lt; T &gt;&gt; *dataList)</td></tr>
<tr class="memdesc:a054eb3b880cd8935d9bfad3a42e1c274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of data into the TaskGraph Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph.  <a href="#a054eb3b880cd8935d9bfad3a42e1c274">More...</a><br /></td></tr>
<tr class="separator:a054eb3b880cd8935d9bfad3a42e1c274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fa554c295c9ff11fde6b3473d53676"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676">consumeData</a> ()</td></tr>
<tr class="memdesc:ab8fa554c295c9ff11fde6b3473d53676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes data from the output of a TaskGraph.  <a href="#ab8fa554c295c9ff11fde6b3473d53676">More...</a><br /></td></tr>
<tr class="separator:ab8fa554c295c9ff11fde6b3473d53676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec690fd65d8cc54c0631f1a813bb07c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; U &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a4ec690fd65d8cc54c0631f1a813bb07c">pollData</a> (size_t microTimeout)</td></tr>
<tr class="memdesc:a4ec690fd65d8cc54c0631f1a813bb07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls for data from the output of the TaskGraph.  <a href="#a4ec690fd65d8cc54c0631f1a813bb07c">More...</a><br /></td></tr>
<tr class="separator:a4ec690fd65d8cc54c0631f1a813bb07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbd07f1ea2ee2afb70665f5873407ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea">isOutputTerminated</a> ()</td></tr>
<tr class="memdesc:acdbd07f1ea2ee2afb70665f5873407ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the output of the TaskGraph has finished producing data.  <a href="#acdbd07f1ea2ee2afb70665f5873407ea">More...</a><br /></td></tr>
<tr class="separator:acdbd07f1ea2ee2afb70665f5873407ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c770403588c32b77f7ffbfdb0474df0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c770403588c32b77f7ffbfdb0474df0">setOutputConnector</a> (std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt; connector)</td></tr>
<tr class="memdesc:a2c770403588c32b77f7ffbfdb0474df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output connector for the task graph configuration.  <a href="#a2c770403588c32b77f7ffbfdb0474df0">More...</a><br /></td></tr>
<tr class="separator:a2c770403588c32b77f7ffbfdb0474df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ea35e80b6f26adaefed94f09598ef7"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a87ea35e80b6f26adaefed94f09598ef7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a87ea35e80b6f26adaefed94f09598ef7">releaseMemory</a> (<a class="el" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">m_data_t</a>&lt; V &gt; memory)</td></tr>
<tr class="memdesc:a87ea35e80b6f26adaefed94f09598ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases memory back to its memory manager.  <a href="#a87ea35e80b6f26adaefed94f09598ef7">More...</a><br /></td></tr>
<tr class="separator:a87ea35e80b6f26adaefed94f09598ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20b128cb5435b26a948f43c533ded4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac20b128cb5435b26a948f43c533ded4b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#ac20b128cb5435b26a948f43c533ded4b">genDotGraph</a> (int flags, int colorFlag) override</td></tr>
<tr class="memdesc:ac20b128cb5435b26a948f43c533ded4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the dot graph as a string. <br /></td></tr>
<tr class="separator:ac20b128cb5435b26a948f43c533ded4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce4d72dc9c5ad94762d75778dfc650f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a8ce4d72dc9c5ad94762d75778dfc650f">debug</a> ()</td></tr>
<tr class="memdesc:a8ce4d72dc9c5ad94762d75778dfc650f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides debug output for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>.  <a href="#a8ce4d72dc9c5ad94762d75778dfc650f">More...</a><br /></td></tr>
<tr class="separator:a8ce4d72dc9c5ad94762d75778dfc650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhtgs_1_1_any_task_graph_conf"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhtgs_1_1_any_task_graph_conf')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhtgs_1_1_any_task_graph_conf.html">htgs::AnyTaskGraphConf</a></td></tr>
<tr class="memitem:ac7404c7ca9008030ddcefad3739ee04b inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ac7404c7ca9008030ddcefad3739ee04b">AnyTaskGraphConf</a> (size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a20c0fbc00b87ccbe193243d8e8c6e63b">pipelineId</a>, size_t <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acd0be59044f6e0921297a4c5e84aec46">numPipelines</a>, std::string baseAddress)</td></tr>
<tr class="memdesc:ac7404c7ca9008030ddcefad3739ee04b inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the <a class="el" href="classhtgs_1_1_any_task_graph_conf.html" title="Implements the base class for the TaskGraphConf class, removing the template arguments and providing ...">AnyTaskGraphConf</a>.  <a href="#ac7404c7ca9008030ddcefad3739ee04b">More...</a><br /></td></tr>
<tr class="separator:ac7404c7ca9008030ddcefad3739ee04b inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802614708b3061b14d45a670111a91ee inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a802614708b3061b14d45a670111a91ee"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a802614708b3061b14d45a670111a91ee">~AnyTaskGraphConf</a> ()</td></tr>
<tr class="memdesc:a802614708b3061b14d45a670111a91ee inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a802614708b3061b14d45a670111a91ee inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5070d48b8ad2c2ff5117424ae719d68c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a5070d48b8ad2c2ff5117424ae719d68c">getTaskManagers</a> ()</td></tr>
<tr class="memdesc:a5070d48b8ad2c2ff5117424ae719d68c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vertices of the TaskGraph.  <a href="#a5070d48b8ad2c2ff5117424ae719d68c">More...</a><br /></td></tr>
<tr class="separator:a5070d48b8ad2c2ff5117424ae719d68c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a6c26e3bd4c1dc3b89b337cb94e1db inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ac1a6c26e3bd4c1dc3b89b337cb94e1db">gatherProfilingData</a> (std::map&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *, <a class="el" href="classhtgs_1_1_task_manager_profile.html">TaskManagerProfile</a> * &gt; *taskManagerProfiles)</td></tr>
<tr class="memdesc:ac1a6c26e3bd4c1dc3b89b337cb94e1db inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers profiling data for this task graph's task managers, which is added into the task manager profiles map.  <a href="#ac1a6c26e3bd4c1dc3b89b337cb94e1db">More...</a><br /></td></tr>
<tr class="separator:ac1a6c26e3bd4c1dc3b89b337cb94e1db inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class V , class W &gt; </td></tr>
<tr class="memitem:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ae20f6e3b02e10eb00d5bbd3510bdf9ff">getIRule</a> (<a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; *iRule)</td></tr>
<tr class="memdesc:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shared_ptr reference for a particular <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a>.  <a href="#ae20f6e3b02e10eb00d5bbd3510bdf9ff">More...</a><br /></td></tr>
<tr class="separator:ae20f6e3b02e10eb00d5bbd3510bdf9ff inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ab580a3d1577bf931655cf71ee3e1afb7">getMemoryAllocator</a> (<a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *allocator)</td></tr>
<tr class="memdesc:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shared_ptr reference for a particular <a class="el" href="classhtgs_1_1_i_memory_allocator.html" title="Abstract class that describes how memory is allocated and freed. ">IMemoryAllocator</a>.  <a href="#ab580a3d1577bf931655cf71ee3e1afb7">More...</a><br /></td></tr>
<tr class="separator:ab580a3d1577bf931655cf71ee3e1afb7 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19d20385562125945430fff451b1347 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa19d20385562125945430fff451b1347"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aa19d20385562125945430fff451b1347">initialize</a> ()</td></tr>
<tr class="memdesc:aa19d20385562125945430fff451b1347 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the task graph just prior to spawning threads. <br /></td></tr>
<tr class="separator:aa19d20385562125945430fff451b1347 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc85669891f97760a92c7c71d500c318 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_any_task_graph_conf_8hpp.html#a2795477e4638b7ba72e6b6aa585cf325">TaskNameConnectorMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#acc85669891f97760a92c7c71d500c318">getTaskConnectorNameMap</a> () const </td></tr>
<tr class="memdesc:acc85669891f97760a92c7c71d500c318 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task name connector map that maps the task name to its input connector.  <a href="#acc85669891f97760a92c7c71d500c318">More...</a><br /></td></tr>
<tr class="separator:acc85669891f97760a92c7c71d500c318 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ade53ccf6a68e5a78a4859ded28787ed1">getCopy</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *orig)</td></tr>
<tr class="memdesc:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the copy for an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> based on some original <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> reference.  <a href="#ade53ccf6a68e5a78a4859ded28787ed1">More...</a><br /></td></tr>
<tr class="separator:ade53ccf6a68e5a78a4859ded28787ed1 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8582a09620c0f9ff506965f44477e8 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a3b8582a09620c0f9ff506965f44477e8">getCopy</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *orig)</td></tr>
<tr class="memdesc:a3b8582a09620c0f9ff506965f44477e8 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the copy for an <a class="el" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. ">AnyITask</a> based on some original <a class="el" href="classhtgs_1_1_any_i_task.html" title="Implements the parent ITask, which removes the template arguments of an ITask. ">AnyITask</a> reference.  <a href="#a3b8582a09620c0f9ff506965f44477e8">More...</a><br /></td></tr>
<tr class="separator:a3b8582a09620c0f9ff506965f44477e8 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_task_manager.html">TaskManager</a>&lt; T, U &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a955128064919d0284de0765aae41cfd3">getTaskManager</a> (<a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, U &gt; *task)</td></tr>
<tr class="memdesc:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task manager that is responsible for a particular <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#a955128064919d0284de0765aae41cfd3">More...</a><br /></td></tr>
<tr class="separator:a955128064919d0284de0765aae41cfd3 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0eb84a2a9990da8c11f353350bf489 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a1d0eb84a2a9990da8c11f353350bf489">addTaskManager</a> (<a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *taskManager)</td></tr>
<tr class="memdesc:a1d0eb84a2a9990da8c11f353350bf489 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a task manager to the task graph.  <a href="#a1d0eb84a2a9990da8c11f353350bf489">More...</a><br /></td></tr>
<tr class="separator:a1d0eb84a2a9990da8c11f353350bf489 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0813fe216c48e7dad0dbf8008f0983f5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0813fe216c48e7dad0dbf8008f0983f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a0813fe216c48e7dad0dbf8008f0983f5">printProfile</a> ()</td></tr>
<tr class="memdesc:a0813fe216c48e7dad0dbf8008f0983f5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints profile data to console for all task managers. <br /></td></tr>
<tr class="separator:a0813fe216c48e7dad0dbf8008f0983f5 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d80a4f7d1b1f672d9bdaffb4d7199 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a425d80a4f7d1b1f672d9bdaffb4d7199">getPipelineId</a> ()</td></tr>
<tr class="memdesc:a425d80a4f7d1b1f672d9bdaffb4d7199 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pipeline ID for the task graph configuration.  <a href="#a425d80a4f7d1b1f672d9bdaffb4d7199">More...</a><br /></td></tr>
<tr class="separator:a425d80a4f7d1b1f672d9bdaffb4d7199 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86445492fc9421c0c5132bd608e2460 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ae86445492fc9421c0c5132bd608e2460">getNumPipelines</a> ()</td></tr>
<tr class="memdesc:ae86445492fc9421c0c5132bd608e2460 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of pipelines that exist for this task graph.  <a href="#ae86445492fc9421c0c5132bd608e2460">More...</a><br /></td></tr>
<tr class="separator:ae86445492fc9421c0c5132bd608e2460 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156114f88890284e1ab81b6053616797 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a156114f88890284e1ab81b6053616797">writeDotToFile</a> (std::string file)</td></tr>
<tr class="memdesc:a156114f88890284e1ab81b6053616797 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the basic dot representation of the task graph to disk.  <a href="#a156114f88890284e1ab81b6053616797">More...</a><br /></td></tr>
<tr class="separator:a156114f88890284e1ab81b6053616797 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af036e1aa6ec1fa431d2428c30d896653 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#af036e1aa6ec1fa431d2428c30d896653">writeDotToFile</a> (std::string file, int flags)</td></tr>
<tr class="memdesc:af036e1aa6ec1fa431d2428c30d896653 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the dot representation of the task graph to disk with additional options such as profiling.  <a href="#af036e1aa6ec1fa431d2428c30d896653">More...</a><br /></td></tr>
<tr class="separator:af036e1aa6ec1fa431d2428c30d896653 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0266ddf4dcfd6907939ac9418bafc6d2 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a0266ddf4dcfd6907939ac9418bafc6d2">updateTaskManagersAddressingAndPipelines</a> ()</td></tr>
<tr class="memdesc:a0266ddf4dcfd6907939ac9418bafc6d2 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the task managers addresses, pipelineIds and the number of pipelines for all tasks in the TaskGraph.  <a href="#a0266ddf4dcfd6907939ac9418bafc6d2">More...</a><br /></td></tr>
<tr class="separator:a0266ddf4dcfd6907939ac9418bafc6d2 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfd2aa56fe389eb612ce95e1b86cfba inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a9bfd2aa56fe389eb612ce95e1b86cfba">getAddress</a> ()</td></tr>
<tr class="memdesc:a9bfd2aa56fe389eb612ce95e1b86cfba inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address for the task graph.  <a href="#a9bfd2aa56fe389eb612ce95e1b86cfba">More...</a><br /></td></tr>
<tr class="separator:a9bfd2aa56fe389eb612ce95e1b86cfba inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9f2a3f4b34b9f4b36433a66749d3ab inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#abc9f2a3f4b34b9f4b36433a66749d3ab">getNumberOfSubGraphs</a> () const </td></tr>
<tr class="memdesc:abc9f2a3f4b34b9f4b36433a66749d3ab inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of sub graphs within this task graph.  <a href="#abc9f2a3f4b34b9f4b36433a66749d3ab">More...</a><br /></td></tr>
<tr class="separator:abc9f2a3f4b34b9f4b36433a66749d3ab inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b405efa32fd885a3b82eca6fe4a42c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0b405efa32fd885a3b82eca6fe4a42c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#af0b405efa32fd885a3b82eca6fe4a42c">genDotGraphContent</a> (int flags)</td></tr>
<tr class="memdesc:af0b405efa32fd885a3b82eca6fe4a42c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the content only of the graph (excludes all graph definitions and attributes) <br /></td></tr>
<tr class="separator:af0b405efa32fd885a3b82eca6fe4a42c inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2dd0d09a53a9bd9652ea0490d0f1ec inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#ada2dd0d09a53a9bd9652ea0490d0f1ec">copyTasks</a> (std::list&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> * &gt; *tasks)</td></tr>
<tr class="memdesc:ada2dd0d09a53a9bd9652ea0490d0f1ec inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of each task from the list of AnyTaskManagers passed as a parameter.  <a href="#ada2dd0d09a53a9bd9652ea0490d0f1ec">More...</a><br /></td></tr>
<tr class="separator:ada2dd0d09a53a9bd9652ea0490d0f1ec inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf4bd5dfbb48517acd389e18fa97960 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aebf4bd5dfbb48517acd389e18fa97960">getTaskManagerCopy</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *iTask)</td></tr>
<tr class="memdesc:aebf4bd5dfbb48517acd389e18fa97960 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the task manager copy for a given <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>.  <a href="#aebf4bd5dfbb48517acd389e18fa97960">More...</a><br /></td></tr>
<tr class="separator:aebf4bd5dfbb48517acd389e18fa97960 inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e7dc6a67d31162ccd0fe0802cd10bf inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a70e7dc6a67d31162ccd0fe0802cd10bf">hasTask</a> (<a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *task)</td></tr>
<tr class="memdesc:a70e7dc6a67d31162ccd0fe0802cd10bf inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> is in the graph or not.  <a href="#a70e7dc6a67d31162ccd0fe0802cd10bf">More...</a><br /></td></tr>
<tr class="separator:a70e7dc6a67d31162ccd0fe0802cd10bf inherit pub_methods_classhtgs_1_1_any_task_graph_conf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a393e82c28c1a3ed0bd619f5ca51da5f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a393e82c28c1a3ed0bd619f5ca51da5f9"></a>
std::list&lt; <a class="el" href="classhtgs_1_1_edge_descriptor.html">EdgeDescriptor</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a393e82c28c1a3ed0bd619f5ca51da5f9">edges</a></td></tr>
<tr class="memdesc:a393e82c28c1a3ed0bd619f5ca51da5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of edges for the graph, represented by edge descriptors to define how the edges are copied/added. <br /></td></tr>
<tr class="separator:a393e82c28c1a3ed0bd619f5ca51da5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc20928ac24a8b3b9d7a2ddd8570ea7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fc20928ac24a8b3b9d7a2ddd8570ea7"></a>
<a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a5fc20928ac24a8b3b9d7a2ddd8570ea7">graphConsumerTaskManager</a></td></tr>
<tr class="memdesc:a5fc20928ac24a8b3b9d7a2ddd8570ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The consumer accessing the TaskGraph's input connector. <br /></td></tr>
<tr class="separator:a5fc20928ac24a8b3b9d7a2ddd8570ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace811b81aafca7ed203fce90ac75f662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace811b81aafca7ed203fce90ac75f662"></a>
std::list&lt; <a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#ace811b81aafca7ed203fce90ac75f662">graphProducerTaskManagers</a></td></tr>
<tr class="memdesc:ace811b81aafca7ed203fce90ac75f662"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of producers that are outputting data to the TaskGraph's output connector. <br /></td></tr>
<tr class="separator:ace811b81aafca7ed203fce90ac75f662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c072839d748de933ae96371313dd52d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c072839d748de933ae96371313dd52d"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a9c072839d748de933ae96371313dd52d">input</a></td></tr>
<tr class="memdesc:a9c072839d748de933ae96371313dd52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input connector for the TaskGraph. <br /></td></tr>
<tr class="separator:a9c072839d748de933ae96371313dd52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6a48dc9c378889e2b48ca70e27776"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93f6a48dc9c378889e2b48ca70e27776"></a>
std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a93f6a48dc9c378889e2b48ca70e27776">output</a></td></tr>
<tr class="memdesc:a93f6a48dc9c378889e2b48ca70e27776"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output connector for the TaskGraph. <br /></td></tr>
<tr class="separator:a93f6a48dc9c378889e2b48ca70e27776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2622ad31f9af482c18e3829348981c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b2622ad31f9af482c18e3829348981c"></a>
<a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhtgs_1_1_task_graph_conf.html#a0b2622ad31f9af482c18e3829348981c">taskConnectorCommunicator</a></td></tr>
<tr class="memdesc:a0b2622ad31f9af482c18e3829348981c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task graph communicator for the task graph. <br /></td></tr>
<tr class="separator:a0b2622ad31f9af482c18e3829348981c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class U&gt;<br />
class htgs::TaskGraphConf&lt; T, U &gt;</h3>

<p>Manages a group of connected ITasks and their connections. </p>
<p>Each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is added into the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> is stored in the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>'s metadata to allow for quick copying using <a class="el" href="classhtgs_1_1_task_graph_conf.html#a6885d5ddfcee1dadee68e5b9a586a0f1" title="Creates an exact copy of this task graph. ">copy()</a>.</p>
<p>The main methods for adding each <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> into the graph are <a class="el" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01" title="Adds an edge to the graph, where one task produces data for a consumer task. ">addEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274" title="Creates a rule edge that is managed by a bookkeeper. ">addRuleEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">addMemoryManagerEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#a0d42580bc4a385943ae53d22108fdef8" title="Adds a CudaMemoryManager edge with the specified name to the TaskGraphConf. ">addCudaMemoryManagerEdge()</a>, <a class="el" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811" title="Sets the task that is consuming data from the input of the graph. ">setGraphConsumerTask()</a>, and <a class="el" href="classhtgs_1_1_task_graph_conf.html#a0857e5a678b01922a513cd2327114864" title="Sets the task that is producing data for the output of the graph. ">addGraphProducerTask()</a></p>
<p>When using these methods, the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> builds a <a class="el" href="classhtgs_1_1_task_manager.html" title="Encapsulates an ITask to interact with an ITask&#39;s functionality. ">TaskManager</a>, which manages an <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a>. Parameters for customizing the thread pool, polling abilities, etc., are specified in the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> constructors: <a class="el" href="classhtgs_1_1_i_task.html#ac23fa74bf05d6a86000422d989ccc5d1" title="Creates an ITask with number of threads equal to 1. ">ITask::ITask()</a></p>
<p>Special memory edge functions are provided. For normal CPU memory edges use: <a class="el" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb" title="Adds a MemoryManager edge with the specified name to the TaskGraphConf. ">addMemoryManagerEdge()</a></p>
<p>For Cuda memory use: <a class="el" href="classhtgs_1_1_task_graph_conf.html#a0d42580bc4a385943ae53d22108fdef8" title="Adds a CudaMemoryManager edge with the specified name to the TaskGraphConf. ">addCudaMemoryManagerEdge()</a></p>
<p>Every <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> has an input and output type (T and U). If a TaskGraph does not have an input or output type, then the data type can be specified as <a class="el" href="classhtgs_1_1_void_data.html" title="VoidData is used for data that is empty/void. ">VoidData</a>. There can be only one task consuming data from the graph. If multiple tasks need to process data from the input, then add a bookkeeper as the first task and rules to distribute data. There can be any number of tasks producing output data for the graph.</p>
<p>To add data into the input of a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef" title="Produces data for the input of the TaskGraph. ">produceData()</a> function. Once finished producing data for the graph, use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d" title="Decrements the input connector and wakes up any consumer of the graph&#39;s input if the input connector ...">finishedProducingData()</a> function to indicate a data input stream is is closing. If additional data streams are added as input for the graph, then use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#a5d9a2ea9704c804e089c1794e1e8e664" title="Increments the number of producers for the task graph. ">incrementGraphProducer()</a> function. By default a task graph starts with one producer for the graph for the main thread, if there are no producers (such as the first task in the graph begins processing immediately), then call <a class="el" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d" title="Decrements the input connector and wakes up any consumer of the graph&#39;s input if the input connector ...">finishedProducingData()</a>.</p>
<p>To process the output of a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676" title="Consumes data from the output of a TaskGraph. ">consumeData()</a> function. To determine if data is no longer being produced by a TaskGraph use the <a class="el" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea" title="Checks if the output of the TaskGraph has finished producing data. ">isOutputTerminated()</a> function. The output of the consumeData function could produce nullptr data when the graph is closing.</p>
<p>Example Usage: </p><div class="fragment"><div class="line"><a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixBlockRequest, MatrixBlockRequest&gt;</a> *taskGraph = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf&lt;MatrixBlockRequest, MatrixBlockRequest&gt;</a>();</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> numLoadThreads = 2;</div><div class="line"><span class="keywordtype">int</span> numMulThreads = 20;</div><div class="line"></div><div class="line">LoadMatrixTask *loadMatrixTask = <span class="keyword">new</span> LoadMatrixTask(numLoadThreads, blockSize, width, height);</div><div class="line">ScalarMultiplyTask *scalMulTask = <span class="keyword">new</span> ScalarMultiplyTask(numMulThreads, blockSize, width, height);</div><div class="line"><a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&gt;</a> *bkTask = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_bookkeeper.html">htgs::Bookkeeper&lt;MatrixBlockData&gt;</a>();</div><div class="line"></div><div class="line">MatrixLoadRule *loadRule = <span class="keyword">new</span> MatrixLoadRule(width/blockSize, height/blockSize);</div><div class="line"></div><div class="line"><span class="comment">// Add tasks to graph</span></div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#aeaf80f060f13a40b41579a8678acad01">addEdge</a>(loadMatrixTask, bkTask);</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#aedfc932815a7b264da00c35d274f5274">addRuleEdge</a>(bkTask, loadRule, scalMulTask);</div><div class="line"></div><div class="line"><span class="comment">// Add memory edges</span></div><div class="line">MatrixAllocator *matrixAlloc = <span class="keyword">new</span> MatrixAllocator(blockSize, blockSize);</div><div class="line"><span class="keywordtype">int</span> poolSize = 50;</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb">addMemoryManagerEdge</a>(<span class="stringliteral">&quot;MatrixA&quot;</span>, loadMatrixTask, matrixAlloc, 50);</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a88adcd11f63ba49703f82f1210d0f0eb">addMemoryManagerEdge</a>(<span class="stringliteral">&quot;MatrixB&quot;</span>, loadMatrixTask, matrixAlloc, 50);</div><div class="line"></div><div class="line"><span class="comment">// Setup graph input/output</span></div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a23520b3b3054e16c59784b0d3a289811">setGraphConsumerTask</a>(loadMatrixTask);</div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a0857e5a678b01922a513cd2327114864">addGraphProducerTask</a>(scalMulTask);</div><div class="line"></div><div class="line"><span class="comment">// Setup runtime and execute</span></div><div class="line"><a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a> *runtime = <span class="keyword">new</span> <a class="code" href="classhtgs_1_1_task_graph_runtime.html">htgs::TaskGraphRuntime</a>(taskGraph);</div><div class="line">runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a1ebd18efd3e1262e46800f98790368a9">executeRuntime</a>();</div><div class="line"></div><div class="line"><span class="comment">// Add input to graph</span></div><div class="line"><span class="keywordflow">for</span> (blockRow = 0; blockRow &lt; blockHeight; blockRow++)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span>(blockCol = 0; blockCol &lt; blockWidth; blockCol++)</div><div class="line">  {</div><div class="line">    <span class="comment">// Request to multiply BlockedA[blockRow, blockCol] .* BlockedB[blockRow, blockCol]</span></div><div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef">produceData</a>(<span class="keyword">new</span> MatrixBlockRequest(blockRow, blockCol, <span class="stringliteral">&quot;MatrixA&quot;</span>));</div><div class="line">    taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a834c5f5f07d3cceac5d7f6f9e128e7ef">produceData</a>(<span class="keyword">new</span> MatrixBlockRequest(blockRow, blockCol, <span class="stringliteral">&quot;MatrixB&quot;</span>));</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Indicate finished producing data</span></div><div class="line">taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#a2c1e54bfce0472b38d422f973d3ba68d">finishedProducingData</a>();</div><div class="line"></div><div class="line"><span class="comment">// Process taskGraph output</span></div><div class="line"><span class="keywordflow">while</span> (!taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#acdbd07f1ea2ee2afb70665f5873407ea">isOutputTerminated</a>())</div><div class="line">{</div><div class="line">  std::shared_ptr&lt;MatrixBlockRequest&gt; mbr = taskGraph-&gt;<a class="code" href="classhtgs_1_1_task_graph_conf.html#ab8fa554c295c9ff11fde6b3473d53676">consumeData</a>();</div><div class="line">  <span class="keywordflow">if</span> (mbr != <span class="keyword">nullptr</span>)</div><div class="line">  {</div><div class="line">    <span class="comment">// ... apply post-processing</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">runtime-&gt;<a class="code" href="classhtgs_1_1_task_graph_runtime.html#a8f2eaf040695178b6f61db7b0ee16c89">waitForRuntime</a>();</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the input data type for the TaskGraph, T must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
    <tr><td class="paramname">U</td><td>the output data type for the TaskGraph, U must derive from <a class="el" href="classhtgs_1_1_i_data.html" title="Class to hold any type of data. ">IData</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad67aeba76921f17058e0972b89146d16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::<a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td>
          <td class="paramname"><em>parentCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a TaskGraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipelineId for this graph </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of pipelines for the graph </td></tr>
    <tr><td class="paramname">baseAddress</td><td>the base address for the task graph to build upon for multiple levels of execution pipelines </td></tr>
    <tr><td class="paramname">parentCommunicator</td><td>the parent task graph communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0d42580bc4a385943ae53d22108fdef8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class IMemoryAllocatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addCudaMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IMemoryAllocatorType &gt;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUcontext *&#160;</td>
          <td class="paramname"><em>contexts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<p>This will create a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> that is bound to some Cuda GPU based on the pipelineId of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
    <tr><td class="paramname">contexts</td><td>the array of all Cuda contexts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the GPU if the allocator-&gt;size() * memoryPoolSize exceeds the total GPU memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e. 'cufftDoubleComplex *' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a806d4e5a57572f548c6682c81b28084e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addCudaMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUcontext *&#160;</td>
          <td class="paramname"><em>contexts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<p>This will create a <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> that is bound to some Cuda GPU based on the pipelineId of the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated (should allocate Cuda memory) </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_cuda_memory_manager.html" title="Implements a MemoryManager that binds the thread responsible for the MemoryManager to a CUDA GPU prio...">CudaMemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager e </td></tr>
    <tr><td class="paramname">contexts</td><td>the array of all Cuda contexts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the GPU if the allocator-&gt;size() * memoryPoolSize exceeds the total GPU memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e. 'cufftDoubleComplex *' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e01d687d11fcd4a7c9bd90f8f65a7f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addCustomMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_memory_manager.html">MemoryManager</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>memoryManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a custom <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<p>This will create a custom memory manager </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">getMemoryTask</td><td></td></tr>
    <tr><td class="paramname">memoryManager</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeaf80f060f13a40b41579a8678acad01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class W , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; V, W &gt; *&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the graph, where one task produces data for a consumer task. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the input type for the producer task </td></tr>
    <tr><td class="paramname">W</td><td>the output/input types for the producer/consumer tasks </td></tr>
    <tr><td class="paramname">X</td><td>the output type for the consumer task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">producer</td><td>the task that is producing data </td></tr>
    <tr><td class="paramname">consumer</td><td>the task that consumes the data from the producer task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0857e5a678b01922a513cd2327114864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addGraphProducerTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, U &gt; *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the task that is producing data for the output of the graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">W</td><td>the input type of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task that produces data that is added as output for the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>There can be multiple tasks that produces for the graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a88adcd11f63ba49703f82f1210d0f0eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class IMemoryAllocatorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IMemoryAllocatorType &gt;&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if the rule connecting the bookkeeper and consumer are shared among multiple graphs that you create. </dd></dl>

</div>
</div>
<a class="anchor" id="a442420d2c9c115ca9f9c644f7e5c985f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addMemoryManagerEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_any_i_task.html">AnyITask</a> *&#160;</td>
          <td class="paramname"><em>getMemoryTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_memory_allocator.html">IMemoryAllocator</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>memoryPoolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_m_m_type_8hpp.html#a9cb5fbc12b3f2ecede03fd2ae6e3fa0b">MMType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> edge with the specified name to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the memory edge, should be unique compared to all memory edges added to the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> and any <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a> within an <a class="el" href="classhtgs_1_1_execution_pipeline.html" title="The ExecutionPipeline class is used to duplicate task graphs, such that each duplicate executes concu...">ExecutionPipeline</a> </td></tr>
    <tr><td class="paramname">getMemoryTask</td><td>the <a class="el" href="classhtgs_1_1_i_task.html" title="An interface to process input data and forward results within a TaskGraph. ">ITask</a> that is getting memory </td></tr>
    <tr><td class="paramname">allocator</td><td>the allocator describing how memory is allocated </td></tr>
    <tr><td class="paramname">memoryPoolSize</td><td>the size of the memory pool that is allocated by the <a class="el" href="classhtgs_1_1_memory_manager.html" title="Processes MemoryData between two ITasks using a memory pool. ">MemoryManager</a> </td></tr>
    <tr><td class="paramname">type</td><td>the type of memory manager </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the memoryPoolSize can cause out of memory errors for the system if the allocator-&gt;size() * memoryPoolSize exceeds the total system memory </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory; i.e., 'double' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedfc932815a7b264da00c35d274f5274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class IRuleType , class W , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addRuleEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>bookkeeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; IRuleType &gt;&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rule edge that is managed by a bookkeeper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the input type for the bookkeeper and rule </td></tr>
    <tr><td class="paramname">IRuleType</td><td>the <a class="el" href="classhtgs_1_1_i_rule.html" title="Provides an interface to send data along RuleManager edges for processing state and dependencies...">IRule</a> that determines when to produce data for the edge (must match the input types of both the bookkeeper and the consumer task) </td></tr>
    <tr><td class="paramname">W</td><td>the output/input type for the rule/consumer task </td></tr>
    <tr><td class="paramname">X</td><td>the output type for the consumer task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bookkeeper</td><td>the bookkeeper task that manages this edge </td></tr>
    <tr><td class="paramname">rule</td><td>the rule that determines when to produce data for the edge </td></tr>
    <tr><td class="paramname">consumer</td><td>the consumer of the rule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use this function if the rule connecting the bookkeeper and consumer are shared among multiple graphs that you create. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3d41cc1d73dfda04f8f9ab48a525980"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V , class W , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::addRuleEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_bookkeeper.html">Bookkeeper</a>&lt; V &gt; *&#160;</td>
          <td class="paramname"><em>bookkeeper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_rule.html">IRule</a>&lt; V, W &gt; *&#160;</td>
          <td class="paramname"><em>iRule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; W, X &gt; *&#160;</td>
          <td class="paramname"><em>consumer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rule edge that is managed by a bookkeeper. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the input type for the bookkeeper and rule </td></tr>
    <tr><td class="paramname">W</td><td>the output/input type for the rule/consumer task </td></tr>
    <tr><td class="paramname">X</td><td>the output type for the consumer task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bookkeeper</td><td>the bookkeeper task that manages this edge </td></tr>
    <tr><td class="paramname">iRule</td><td>the rule that determines when to produce data for the edge </td></tr>
    <tr><td class="paramname">consumer</td><td>the consumer of the rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8fa554c295c9ff11fde6b3473d53676"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;U&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::consumeData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consumes data from the output of a TaskGraph. </p>
<p>It is possible for consumeData to return nullptr if the last Task has finished. Therefore, when consuming data from a TaskGraph it is important to have a check for nullptr prior to processing that data. </p><dl class="section return"><dt>Returns</dt><dd>one data element from the output of the TaskGraph or nullptr if the last task is closing. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The task producing data for the TaskGraph will send nullptr to the connector, so the thread consuming data should check for nullptr prior to processing the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a6885d5ddfcee1dadee68e5b9a586a0f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_any_task_graph_conf.html">AnyTaskGraphConf</a>* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an exact copy of this task graph. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the task graph. </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aaedf378d624b872042d093017c8ad8ab">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a class="anchor" id="a163409dd38587f67b49502835ca107fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPipelines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipeline Id </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of pipelines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the copy of the task graph </dd></dl>

</div>
</div>
<a class="anchor" id="a32a135c436eb931cc7d002758e021335"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a>&lt;T, U&gt;* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pipelineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numPipelines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; U &gt;&gt;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>baseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a> *&#160;</td>
          <td class="paramname"><em>parentCommunicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a mirror copy of the TaskGraph with the specified pipelineId and number of pipelines, and updates the input and output connectors for the graph copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipelineId</td><td>the pipeline Id </td></tr>
    <tr><td class="paramname">numPipelines</td><td>the number of pipelines </td></tr>
    <tr><td class="paramname">input</td><td>the input connector to be used for the graph's input </td></tr>
    <tr><td class="paramname">output</td><td>the output connector to be used for the graph's output </td></tr>
    <tr><td class="paramname">baseAddress</td><td>the base address for the task graph to build upon for multiple levels of execution pipelines </td></tr>
    <tr><td class="paramname">parentCommunicator</td><td>the parent task graph communicator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the copy of the task graph </dd></dl>

</div>
</div>
<a class="anchor" id="a8ce4d72dc9c5ad94762d75778dfc650f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::debug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides debug output for the <a class="el" href="classhtgs_1_1_task_graph_conf.html" title="Manages a group of connected ITasks and their connections. ">TaskGraphConf</a>. </p>
<dl class="section note"><dt>Note</dt><dd>#define DEBUG_FLAG to enable debugging </dd></dl>

</div>
</div>
<a class="anchor" id="a2c1e54bfce0472b38d422f973d3ba68d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::finishedProducingData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements the input connector and wakes up any consumer of the graph's input if the input connector is finished producing data. </p>
<dl class="section note"><dt>Note</dt><dd>This should be called by the main thread when all data is finished being produced for this task graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e19bcf91fb99751ba47f32bc755ba0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a>* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::getGraphConsumerTaskManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function that gets the task manager that is consuming data from the graph's input. </p>
<dl class="section return"><dt>Returns</dt><dd>the task manager that is consuming data from the graph's input. </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a6f01c03d02aeac3e0bf351946cb740c9">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a class="anchor" id="a2c30736911d28514e76cb44fe92351f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classhtgs_1_1_any_task_manager.html">AnyTaskManager</a> *&gt;* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::getGraphProducerTaskManagers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the list of task managers that are producing data for the graph's output. </p>
<dl class="section return"><dt>Returns</dt><dd>the list of task managers that are producing data for the graph's output. </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a679be556aed8d94b79e24d02aa19b389">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a class="anchor" id="abefecdde12a738f08e41f410015afb6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a>&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::getInputConnector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that gets the connector used for graph input. </p>
<dl class="section return"><dt>Returns</dt><dd>the connector used for graph input </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a56173dc596a66b2f186b3471c412706a">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a class="anchor" id="a2d3a06907ead06a968ab1530922a0ea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a>&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::getOutputConnector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that gets the connector used for graph output. </p>
<dl class="section return"><dt>Returns</dt><dd>the connector used for graph output </dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#aab64ec2f1dfebbea602daeb0280c5030">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a class="anchor" id="a680be3c29e61ed66fd47ff0a94567c9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhtgs_1_1_task_graph_communicator.html">TaskGraphCommunicator</a>* <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::getTaskGraphCommunicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function that gets the task graph communicator. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="classhtgs_1_1_any_task_graph_conf.html#a1a5362a39635bf9b223dd5ac71f728f0">htgs::AnyTaskGraphConf</a>.</p>

</div>
</div>
<a class="anchor" id="a5d9a2ea9704c804e089c1794e1e8e664"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::incrementGraphProducer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the number of producers for the task graph. </p>
<dl class="section note"><dt>Note</dt><dd>The input connector is automatically incremented when creating a graph, so this should only be called if additional sources will be producing data other than the main function. </dd></dl>

</div>
</div>
<a class="anchor" id="acdbd07f1ea2ee2afb70665f5873407ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::isOutputTerminated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the output of the TaskGraph has finished producing data. </p>
<dl class="section return"><dt>Returns</dt><dd>whether the output is finished or not </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if the output is no longer producing data </td></tr>
    <tr><td class="paramname">FALSE</td><td>if the output is not finished producing data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ec690fd65d8cc54c0631f1a813bb07c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;U&gt; <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::pollData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>microTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Polls for data from the output of the TaskGraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">microTimeout</td><td>the timeout time in microseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the data or nullptr if the timeout period expires. </dd></dl>

</div>
</div>
<a class="anchor" id="a834c5f5f07d3cceac5d7f6f9e128e7ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces data for the input of the TaskGraph. </p>
<p>Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being added to the TaskGraph input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data being passed will be wrapped into a std::shared_ptr&lt;T&gt;(data) </dd></dl>

</div>
</div>
<a class="anchor" id="a614839d80ed96f8938d38606e895225a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces data for the input of the TaskGraph. </p>
<p>Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being added to the TaskGraph input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a054eb3b880cd8935d9bfad3a42e1c274"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::produceData </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::shared_ptr&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dataList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of data into the TaskGraph Must specify the TaskGraph input using addGraphInputConsumer() and use incrementGraphInputProducer() to indicate an input stream is feeding data to the TaskGraph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataList</td><td>the list of data to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87ea35e80b6f26adaefed94f09598ef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::releaseMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_types_8hpp.html#a3b26154a91264a0136c960befa0818e5">m_data_t</a>&lt; V &gt;&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases memory back to its memory manager. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>the type of memory data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>the memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The m_data_t must have originated within this task graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a23520b3b3054e16c59784b0d3a289811"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<div class="memtemplate">
template&lt;class W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::setGraphConsumerTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhtgs_1_1_i_task.html">ITask</a>&lt; T, W &gt; *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the task that is consuming data from the input of the graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">W</td><td>the output type of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task that consumes data that is added into the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only one task consumes data from the graph. If multiple tasks need data from the graph, then a bookkeeper should be added to distribute data among the multiple tasks. </dd></dl>

</div>
</div>
<a class="anchor" id="a431a592aa2e39914fefef99e99cc2e54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::setInputConnector </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the input connector for the task graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input connector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ac7e33e842cbcc582ddb0a869975588"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::setOutputConnector </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_connector.html">Connector</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the output connector for the task graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>the output connector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c770403588c32b77f7ffbfdb0474df0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhtgs_1_1_task_graph_conf.html">htgs::TaskGraphConf</a>&lt; T, U &gt;::setOutputConnector </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classhtgs_1_1_any_connector.html">AnyConnector</a> &gt;&#160;</td>
          <td class="paramname"><em>connector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the output connector for the task graph configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connector</td><td>the output connector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/tjb3/phd-research/HTGS/src/htgs/api/<a class="el" href="_execution_pipeline_8hpp_source.html">ExecutionPipeline.hpp</a></li>
<li>/home/tjb3/phd-research/HTGS/src/htgs/api/<a class="el" href="_task_graph_conf_8hpp_source.html">TaskGraphConf.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>htgs</b></li><li class="navelem"><a class="el" href="classhtgs_1_1_task_graph_conf.html">TaskGraphConf</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
